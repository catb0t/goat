<goat>
	<v value="0.2 &quot;Goatling&quot;"/>
	<s name="Introduction">
		<p><b>Goat</b> is a high-level, dynamic, weakly typed, prototype-based, multi-paradigm, and interpreted programming language, based on JavaScript. It supports the basic functionality of JavaScript, but in addition, it adds support for multithreading, multiple inheritance, operator overloading (all as in C ++), simplified syntax, and so on.</p>
		<p>Why "Goat"? At first, I wanted to name this programming language as "Go", but unfortunately, some little-known company (it seems "Google" or something like that) has already developed a programming language with that name. After a while, when I programmed this interpreter on a laptop lying in a hammock, I was suddenly bitten by my goat. I thought that once the name "Go" is occupied, then perhaps the name "Goat" is no worse. I immediately named the project folder this name and since then it has not changed.</p>
	</s>
	
	<s name="Where to download the latest release">
		<p>On GitHub: <url>https://github.com/kniazkov/goat/releases/latest</url>.</p>
	</s>
	
	<s name="How to launch Goat script">
		<s name="Quick start">
			<p>Just download the executable file, open console, type executable name and specify a script file name as a parameter:</p>
			<c>goat.exe program.goat</c>
		</s>
		<s name="Command line parameters">
			<p>The Goat interpreter parses command line arguments as follows. All arguments started with two hyphens are internal parameters of the interpreter ("options"). The first argument which is not an option is the name of the script file. All next arguments send to script.</p>
			<p>For example,</p>
			<c>goat.exe --lib=../lib program.goat arg1 arg2</c>
			<p>or, the same thing:</p>
			<c>goat.exe program.goat --lib=../lib arg1 arg2</c>
			<p>or:</p>
			<c>goat.exe program.goat arg1 arg2 --lib=../lib</c>
			<p>where: <c>goat.exe</c> is Goat executable, <c>program.goat</c> is name of the script, <c>--lib=../lib</c> is option of the interpterer, <c>arg1</c> and <c>arg2</c> are arguments of the script.</p>
			<p>Here is a list of interpreter options:</p>
			<h name="--lib">
				<p>Path (paths) to external libraries (to importable files). For example, a path to the Goat standard library. Several paths can be separated by a semicolon.</p>
				<c>goat.exe program.goat --lib=c:\goat\lib;c:\project</c>
				<p>Note about path delimiting character, this is most commonly the slash ("/") or the backslash  ("\"). While the interpreter parsed paths, it changes delimiting characters to the character used in the current platform. Say, for Windows, all delimiter characters replaced to the backslash, and for Linux (Unix) - to slash. So path <c>--lib=..\folder\lib</c> interpreted as well as path <c>--lib=../folder/lib</c>, for all platforms.</p>
			</h>
			<h name="--debug">
				<p>The Goat interpreter launched in debug mode. It means that interpretation will stop and set step-by-step mode when the interpreter executes <c>debug;</c> statement.</p>
			</h>
			<h name="--gc">
				<p>One of three modes of garbage collection. <c>--gc=serial</c> enable serial mode, it means that the garbage collector periodically stops all threads (but it takes low processor resources for collection and has small memory overhead). <c>--gc=parallel</c> does not stop threads (but it constantly uses some processor resources and also it uses some extra memory), this mode enabled by default. <c>--gc=debug</c> used for debugging purposes for interpreter developer, it calls collector after each statement of a script and this is <b>very</b> slow.</p>
				<p>If you don't know what "garbage collection" means, please do not use this parameter, parallel collector is okay for most puЗамечание. Значительная часть rposes.</p>
			</h>
		</s>
	</s>
	
	<s name="The language reference">
		<p><b>Important note. A significant part of this chapter is the redesigned tutorial from: <url>https://www.w3schools.com/js/default.asp</url>. Since the Goat language is the modified JavaScript language, so the description of the Goat language is the modified description of the  Javascript language. Any coincidences are NOT random.</b></p>
		<s name="Hello world">
			<p>Create a new file, say <c>hello_world.goat</c> (file extension does not matter) containing one line:</p>
			<c>print("Hello, world!");</c>
			<p>and then launch it:</p>
			<c>goat.exe hello_world.goat</c>
			<p>That's all. The interpreter will start the script and will print <c>Hello, world!</c> to the console.</p>
		</s>
		<s name="Internationalization and localization">
			<p>It possible to use any Unicode characters in string literals. The Goat interpreter parses source files in UTF-8  format. Output stream also encoded to UTF-8. The previous example, but contains some "special" symbols:</p>
			<c>print("Bonjour, réalité cruelle et ingrate!");</c>
		</s>
		<s name="Program and statements">
			<s name="Program">
				<p>A computer program is a list of "instructions" to be "executed" by a computer. In a programming language, these programming instructions are called <b>statements.</b></p>
				<p>A <b>Goat program is a list of</b> programming <b>statements.</b></p>
				<c><![CDATA[
					var x, a, b; // statement 1
					a = 2; // statement 2
					b = 3; //       ... 3
					x = a + b; //       ... 4
					print(x); //       ... 5]]>
				</c>
				<p>Goat programs are executed by the Goat interpreter.</p>
			</s>
			<s name="Statements">
				<p>Goat statements are composed of: <b>Values</b>, <b>Operators</b>, <b>Expressions</b>, <b>Keywords</b>, and <b>Comments</b>.</p>
				<p>The statements are executed, one by one, in the same order as they are written.</p>
			</s>
			<s name="Semicolons">
				<p>Semicolons <c>;</c> separate Goat statements. Add a semicolon at the end of each executable statement:</p>
				<c><![CDATA[
					var x, a, b; // declare 3 variables
					a = 2; // assign the value 2 to 'a'
					b = 3; // assign the value 6 to 'b'
					x = a + b; // assign the sum of 'a' and 'b' to 'x'
					print(x); // print value of 'x']]>
				</c>
				<p>When separated by semicolons, multiple statements on one line are allowed:</p>
				<c>a = 2; b = 3; x = a + b;</c>
				<p>Though ending statements with a semicolon is not required, but highly recommended. This example is correct:</p>
				<c>print(2 + 3) // no semicolon at the end</c>
			</s>
			<s name="White space">
				<p>Goat parse tabulations and line breaks as white spaces. Goat ignores multiple spaces. You can add white space to your script to make it more readable. The following statements are equivalent:</p>
				<c><![CDATA[
					var a, b = 0;
					var a, b=0;
					var a,
						b = 0;]]>
				</c>
			</s>
			<s name="Code blocks">
				<p>Goat statements can be grouped together in code blocks, inside curly brackets <c>{...}</c>. The purpose of code blocks is to define statements to be executed together. One place you will find statements grouped together in blocks, is in Goat functions:</p>
				<c><![CDATA[
					var f = $(a, b) {
						var x;
						var y;
						x = a + b;
						y = a - b;
						print("summ: " + x + ", diff: " + y);
					};]]>
				</c>
			</s>
			<s name="Keywords and keyword sequences">
				<p>Goat statements often start with a keyword to identify the Goat action to be performed. Here is a list of the keywords (or keyword sequences):</p>
				<t>
					<h>
						<c width="180">Keyword</c>
						<c>Description</c>
					</h>
					<r>
						<c><c>var</c></c>
						<c>Declares a variable</c>
					</r>
					<r>
						<c><c>function</c> or <c>$</c></c>
						<c>Declares a function (method)</c>
					</r>
					<r>
						<c><c>thread</c></c>
						<c>Declares a thread</c>
					</r>
					<r>
						<c><c>return</c></c>
						<c>Exits a function (method)</c>
					</r>
					<r>
						<c><c>if</c>..<c>else if</c>..<c>else</c></c>
						<c>Marks a block of statements to be executed, depending on a condition</c>
					</r>
					<r>
						<c><c>switch</c>(<c>case</c>, <c>default)</c></c>
						<c>Marks a block of statements to be executed, depending on different cases</c>
					</r>
					<r>
						<c><c>for</c>(<c>in</c>)</c>
						<c>Marks a block of statements to be executed, as long as a condition is true</c>
					</r>
					<r>
						<c><c>while</c>, <c>do</c>..<c>while</c></c>
						<c>Executes a block of statements, and repeats the block, while a condition is true</c>
					</r>
					<r>
						<c><c>break</c></c>
						<c>Terminates a switch or a loop</c>
					</r>
					<r>
						<c><c>continue</c></c>
						<c>Jumps out of a loop and starts at the top</c>
					</r>
					<r>
						<c><c>try</c>..<c>catch</c>..<c>finally</c></c>
						<c>Implements error handling to a block of statements</c>
					</r>
					<r>
						<c><c>throw</c></c>
						<c>Throws an exception</c>
					</r>
					<r>
						<c><c>new</c></c>
						<c>Creates a new object</c>
					</r>
					<r>
						<c><c>import</c></c>
						<c>Imports a source file</c>
					</r>
					<r>
						<c><c>debug</c></c>
						<c>Stops the execution of Goat script, and switch the interpreter to debug (step-by-step) mode</c>
					</r>
				</t>
				<p>Goat keywords are reserved words. Reserved words cannot be used as names for variables.</p>
			</s>
		</s>
		<s name="Syntax">
			<p>Goat syntax is the set of rules, how Goat programs are constructed:</p>
			<c><![CDATA[
				var a, b, x; // How to declare variables
				a = 2; // How to assign values
				b = 3;
				x = a + b; // How to compute values
				print(x); // How to call functions
			]]>
			</c>
			<s name="Values">
				<p>The Goat syntax defines two types of values: fixed values and variable values. Fixed values are called <b>literals.</b> Variable values are called <b>variables.</b></p>
				<s name="Literals">
					<p>The most important rules for writing fixed values are:</p>
					<p><b>Integer numbers</b> are written without decimals:</p>
					<c>123</c>
					<p><b>Real numbers</b> are written with decimals, decimal separator is a dot:</p>
					<c>0.001</c>
					<p><b>Strings</b> are text, written within double quotes:</p>
					<c>"Hello"</c>
					<p><b>Chars</b> are symbols written within single quotes:</p>
					<c>'A'</c>
				</s>
				<s name="Variables">
					<p>In a programming language, variables are used to store data values. Goat uses the <c>var</c> keyword to <b>declare</b> variables. An <b>equal sign</b> is used to <b>assign</b> values to variables.</p>
					<p>In this example, <c>x</c> is defined as a variable. Then, <c>x</c> is assigned (given) the value 10:</p>
					<c><![CDATA[
						var x;
						x = 10;]]>
					</c>
				</s>
			</s>
			<s name="Operators">
				<p>Goat uses <b>arithmetic operators</b> ( <c>+ - *  /</c> ) to <b>compute</b> values:</p>
				<c>(5 + 6) * 10</c>
				<p>Goat uses an <b>assignment operator</b> ( = ) to <b>assign</b> values to variables:</p>
				<c><![CDATA[
					var a, b;
					a = 2;
					b = 3;]]>
				</c>
			</s>
			<s name="Expressions">
				<p>An <b>expression</b> is a combination of literals, variables, function calls, other expression and operators, which computes to a value. The computation is called an evaluation. For example, 5 * 10 evaluates to 50:</p>
				<c>5 * 10</c>
				<p>Expressions can also contain variable values:</p>
				<c>x * 2</c>
				<p>...or function calls:</p>
				<c>x * sin(y)</c>
				<p>The values can be of various types, such as numbers and strings:</p>
				<c>"Hello" + ", " + "world"</c>
			</s>
			<s name="Identifiers">
				<p><b>Identifiers</b> are names.</p>
				<p>In Goat, identifiers are used to name variables. The rules for legal names are much the same in most programming languages. In Goat, the first character must be a letter or an underscore (<c>_</c>). Subsequent characters may be letters, digits or underscores. Numbers are not allowed as the first character.</p>
			</s>
			<s name="Case sensitive">
				<p>All Goat identifiers are case sensitive. The variables <c>maxValue</c> and <c>maxvalue</c>, are two different variables.</p>
				<c><![CDATA[
					var maxValue, maxvalue;
					maxValue = 10;
					maxvalue = 0.1;]]>
				</c>
			</s>
		</s>
		<s name="Comments">
			<p>Goat comments can be used to explain Goat code, and to make it more readable. Goat comments can also be used to prevent execution, when testing alternative code.</p>
			<s name="Single line comments">
				<p>Single line comments start with <c>//</c>. Any text between <c>//</c> and the end of the line will be ignored by Goat (will not be executed). This example uses a single-line comment before each code line:</p>
				<c><![CDATA[
					// Create object:
					var obj = {};
					// Add a field to the object:
					obj.value = 10; ]]>
				</c>
				<p>This example uses a single line comment at the end of each line to explain the code:</p>
				<c><![CDATA[
					var x = 5; // Declare x, give it the value of 5
					var y = x + 2;  // Declare y, give it the value of x + 2]]>
				</c>
			</s>
			<s name="Multi-line comments">
				<p>Multi-line comments start with <c>/*</c> and end with <c>*/</c>. Any text between <c>/*</c> and <c>*/</c> will be ignored by Goat. This example uses a multi-line comment (a comment block) to explain the code:</p>
				<c><![CDATA[
					/*
					The code below declares the function which calculates
					and print sum and difference of two arguments
					*/
					var f = $(a, b) {
						var x;
						var y;
						x = a + b;
						y = a - b;
						print("summ: " + x + ", diff: " + y);
					};]]>
				</c>
			</s>
			<s name="Using comments to prevent execution">
				<p>Using comments to prevent execution of code is suitable for code testing. Adding <c>//</c> in front of a code line changes the code lines from an executable line to a comment. This example uses <c>//</c> to prevent execution of one of the code lines:</p>
				<c><![CDATA[
					var person = {};
					person.name = "Ivan";
					//person.gender = "Male";
					person.age = 33;]]>
				</c>
				<p>This example uses a comment block to prevent execution of multiple lines:</p>
				<c><![CDATA[
					var person = {};
					person.name = "Ivan";
					/*
					person.gender = "Male";
					person.age = 33;
					*/]]>					
				</c>
			</s>
		</s>
		<s name="Variables">
			<p>Goat <b>variables</b> are containers for storing data values. In this example, <c>x</c>, <c>y</c>, and <c>z</c>, are variables:</p>
			<c><![CDATA[
				var x = 5;
				var y = 6;
				var z = x + y;]]>					
			</c>
			<s name="Identifiers">
				<p>All Goat variables must be identified with unique names. These unique names are called <b>identifiers.</b> Identifiers can be short names (like <c>x</c> and <c>y</c>) or more descriptive names (<c>age</c>, <c>sum</c>, <c>totalVolume</c>). The general rules for constructing names for variables (unique identifiers) are:</p>
				<l>
					<i>names can contain letters, digits and underscores;</i>
					<i>names must begin with a letter;</i>
					<i>names can also begin with <c>_</c>;</i>
					<i>names are case sensitive (<c>y</c> and <c>Y</c> are different variables);</i>
					<i>reserved words (like Goat keywords) cannot be used as names.</i>
				</l>
			</s>
			<s name="Data types">
				<p>Goat can handle many types of data. Goat variables can hold numbers like 100 and text values like "Hello". Basic data types are:</p>
				<p><b>Integer</b> number (without decimal character):</p>
				<c>var i = 10;</c>
				<p><b>Real</b> (floating-point) number:</p>
				<c>var r = 0.01;</c>
				<p><b>String:</b></p>
				<c>var s = "Hello";</c>
				<p><b>Char</b>(single symbol):</p>
				<c>var c = 'A';</c>
				<p>And <b>Boolean:</b></p>
				<c>var b = true;</c>
			</s>
			<s name="Declaring (creating) Goat variables">
				<p>Creating a variable in Goat is called "declaring" a variable. You declare a JavaScript variable with the <c>var</c> keyword:</p>
				<c>var name;</c>
				<p>After the declaration, the variable has no value (technically it has the value of <c>undefined</c>). To assign a value to the variable, use the equal sign:</p>
				<c>name = "Ivan";</c>
				<p>You can also assign a value to the variable when you declare it:</p>
				<c>var name = "Ivan";</c>
			</s>
			<s name="One statement, many variables">
				<p>You can declare many variables in one statement. Start the statement with <c>var</c> and separate the variables by comma:</p>
				<c>var name = "Ivan", age = 33, gender = "male";</c>
				<p>A declaration can span multiple lines:</p>
				<c><![CDATA[
					var name = "Ivan",
						age = 33,
						gender = "male";]]>
				</c>
			</s>
			<s name="Undefined">
				<p>Variables are often declared without a value. The value can be something that has to be calculated, or something that will be provided later, like user input. A variable declared without a value will have the value <c>undefined</c>.</p>
				<c>var name; // value of 'name' is undefined</c>
			</s>
			<s name="Re-declaring variables">
				<p>If you re-declare a Goat variable, it will lose its value.</p>
				<c><![CDATA[
					var name = "Ivan";
					// do something...
					var name; // now, value of 'name' if undefined]]>
				</c>
			</s>
			<s name="Arithmetic">
				<p>As with algebra, you can do arithmetic with Goat variables, using operators like <c>=</c> and <c>+</c>:</p>
				<c>var x = 5 + 2 + 3;</c>
				<p>You can also add strings, but strings will be concatenated:</p>
				<c>var s = "Hello" + ", " + "world!"</c>
				<p>Also try this. The Goat language will convert second operator to string if the first operator is string:</p>
				<c>var s = "Value is" + ' ' + 5;</c>
			</s>
		</s>
		<s name="Operators">
			<s name="Examples">
				<p>The <b>assignment</b> operator (<c>=</c>) assigns a value to a variable.</p>
				<c>var x = 10;</c>
				<p>The <b>addition</b> operator (<c>+</c>) adds numbers:</p>
				<c><![CDATA[
					var a = 2;
					var b = 3;
					var c = a + b;]]>
				</c>
				<p>The <b>multiplication</b> operator (<c>*</c>) multiplies numbers.</p>
				<c><![CDATA[
					var a = 2;
					var b = 3;
					var c = a * b;]]>
				</c>
			</s>
			<s name="Arithmetic operators">
				<p>Arithmetic operators are used to perform arithmetic on numbers:</p>
				<t>
					<h>
						<c width="100">Operator</c>
						<c>Description</c>
					</h>
					<r>
						<c><c>+</c></c>
						<c>Addition</c>
					</r>
					<r>
						<c><c>-</c></c>
						<c>Subtraction</c>
					</r>
					<r>
						<c><c>*</c></c>
						<c>Multiplication</c>
					</r>
					<r>
						<c><c>/</c></c>
						<c>Division</c>
					</r>
					<r>
						<c><c>%</c></c>
						<c>Modulus (remainder)</c>
					</r>
					<r>
						<c><c>++</c></c>
						<c>Increment</c>
					</r>
					<r>
						<c><c>--</c></c>
						<c>Decrement</c>
					</r>
				</t>
			</s>
			<s name="Assignment operators">
				<p>Assignment operators assign values to Goat variables. </p>
				<t>
					<h>
						<c width="100">Operator</c>
						<c width="100">Example</c>
						<c>Same as</c>
					</h>
					<r>
						<c><c>=</c></c>
						<c>x = y</c>
						<c></c>
					</r>
					<r>
						<c><c>+=</c></c>
						<c>x += y</c>
						<c>x = x + y</c>
					</r>
					<r>
						<c><c>-=</c></c>
						<c>x -= y</c>
						<c>x = x - y</c>
					</r>
					<r>
						<c><c>*=</c></c>
						<c>x *= y</c>
						<c>x = x * y</c>
					</r>
					<r>
						<c><c>/=</c></c>
						<c>x /= y</c>
						<c>x = x / y</c>
					</r>
					<r>
						<c><c>%=</c></c>
						<c>x %= y</c>
						<c>x = x % y</c>
					</r>
				</t>
				<p>The <b>addition assignment</b> operator (<c>+=</c>) adds a value to a variable.</p>
				<c><![CDATA[
					var x = 10;
					x += 5;]]>
				</c>
				<p>Value of <c>x</c> will be: <c>15</c></p>
			</s>
			<s name="String operators">
				<p>The <c>+</c> and <c>+=</c> operators can also be used to add (concatenate) strings.</p>
				<c><![CDATA[
					var a = "Hello";
					var b = "world";
					var s = a + ", " + b;]]>
				</c>
				<p>Value of <c>s</c> will be: <c>Hello, world!</c></p>
			</s>
			<s name="Adding strings and not-strings">
				<p>Adding two numbers, will return the sum, but adding a string and a not-string (number, symbol etc) will return a string:</p>
				<c><![CDATA[
					var x = 2 + 3;
					var s = "result is: " + x;]]>
				</c>
				<p>Value of <c>s</c> will be: <c>result is: 5</c></p>
			</s>
			<s name="Comparison operators">
				<t>
					<h>
						<c width="100">Operator</c>
						<c>Description</c>
					</h>
					<r>
						<c><c>==</c></c>
						<c>Equal to</c>
					</r>
					<r>
						<c><c>!=</c></c>
						<c>Not equal</c>
					</r>
					<r>
						<c><c>&gt;</c></c>
						<c>Greater than</c>
					</r>
					<r>
						<c><c>&lt;</c></c>
						<c>Less than</c>
					</r>
					<r>
						<c><c>&gt;=</c></c>
						<c>Greater than or equal to</c>
					</r>
					<r>
						<c><c>&lt;=</c></c>
						<c>Less than or equal to</c>
					</r>
					<r>
						<c><c>?</c></c>
						<c>Ternary operator</c>
					</r>
				</t>
			</s>
			<s name="Logical operators">
				<p>Logical operators work with binary (<c>Boolean</c>) type.</p>
				<t>
					<h>
						<c width="100">Operator</c>
						<c>Description</c>
					</h>
					<r>
						<c><c>&amp;&amp;</c></c>
						<c>Logical and</c>
					</r>
					<r>
						<c><c>||</c></c>
						<c>Logical or</c>
					</r>
					<r>
						<c><c>!</c></c>
						<c>Logical not</c>
					</r>
				</t>
			</s>
			<s name="Bitwise operators">
				<p>Bitwise operators work with <c>Integer</c> type.</p>
				<t>
					<h>
						<c width="100">Operator</c>
						<c>Description</c>
						<c>Example</c>
						<c>Same as</c>
						<c>Result</c>
						<c>Decimal</c>
					</h>
					<r>
						<c><c>&amp;</c></c>
						<c>And</c>
						<c>5 &amp; 1</c>
						<c>0101 &amp; 0001</c>
						<c>0001</c>
						<c>1</c>
					</r>
					<r>
						<c><c>|</c></c>
						<c>Or</c>
						<c>5 | 1</c>
						<c>0101 | 0001</c>
						<c>0101</c>
						<c>5</c>
					</r>
					<r>
						<c><c>~</c></c>
						<c>Not</c>
						<c>~5</c>
						<c>~0101</c>
						<c>...111010</c>
						<c>-6</c>
					</r>
					<r>
						<c><c>^</c></c>
						<c>Xor</c>
						<c>5 ^ 1</c>
						<c>0101 ^ 0001</c>
						<c>0100</c>
						<c>4</c>
					</r>
					<r>
						<c><c>&lt;&lt;</c></c>
						<c>Left shift</c>
						<c>5 &lt;&lt; 1</c>
						<c>0101 &lt;&lt; 1</c>
						<c>1010</c>
						<c>10</c>
					</r>
					<r>
						<c><c>&gt;&gt;</c></c>
						<c>Signed right shift</c>
						<c>5 &gt;&gt; 1</c>
						<c>0101 &gt;&gt; 1</c>
						<c>0010</c>
						<c>2</c>
					</r>
					<r>
						<c><c>&gt;&gt;&gt;</c></c>
						<c>Zero fill right shift</c>
						<c>5 &gt;&gt;&gt; 1</c>
						<c>0101 &gt;&gt;&gt; 1</c>
						<c>0010</c>
						<c>2</c>
					</r>
				</t>
			</s>
		</s>
		<s name="Arithmetic">
			<s name="Arithmetic Operations">
				<p>A typical arithmetic operation operates on two numbers. The two numbers can be literals:</p>
				<c>var x = 100 + 50;</c>
				<p>or variables:</p>
				<c>var x = a + b;</c>
				<p>or expressions:</p>
				<c>var x = (100 + 50) * a;</c>
			</s>
			<s name="Operators and operands">
				<p>The numbers (in an arithmetic operation) are called <b>operands.</b></p>
				<p>The operation (to be performed between the two operands) is defined by an <b>operator.</b></p>
				<t>
					<h>
						<c width="100">Operand</c>
						<c width="100">Operator</c>
						<c>Operand</c>
					</h>
					<r>
						<c>100</c>
						<c>+</c>
						<c>50</c>
					</r>
				</t>
				<p>If at least one of operators is a real number, result will be a real number. If both operators are integers, the result will be integer.</p>
				<p>The <b>addition</b> operator (<c>+</c>) adds numbers.</p>
				<c><![CDATA[
					var a = 2;
					var b = 3;
					var c = a + b; // 5]]>
				</c>
				<p>The <b>subtraction </b> operator (<c>-</c>) subtracts  numbers.</p>
				<c><![CDATA[
					var a = 2;
					var b = 3;
					var c = a - b; // -1]]>
				</c>
				<p>The <b>multiplication</b> operator (<c>*</c>) multiplies numbers.</p>
				<c><![CDATA[
					var a = 2;
					var b = 3;
					var c = a * b; // 6]]>
				</c>
				<p>The <b>division</b> operator (<c>/</c>) divides  numbers.</p>
				<c><![CDATA[
					var a = 6;
					var b = 2;
					var c = a / b; // 3]]>
				</c>
				<p>If at least one of operators is a real number, the Goat interpreter performs real division (for example, <c>6.0 / 4 = 1.5</c>). If both operators are integers, the interpreter performs integer division, i.e. the fractional part of the result will be lost (<c>6 / 4 = 1</c>).</p>
				<p>The <b>modular</b> operator (<c>%</c>) returns the division remainder.</p>
				<c><![CDATA[
					var a = 17;
					var b = 10;
					var c = a % b; // 7]]>
				</c>
				<p>The <b>increment </b> operator (<c>++</c>) increments numbers.</p>
				<c><![CDATA[
					var a = 2;
					a++; // 3]]>
				</c>
				<p>The <b>decrement</b> operator (<c>--</c>) decrements numbers.</p>
				<c><![CDATA[
					var a = 2;
					a--; // 1]]>
				</c>
			</s>
			<s name="Operator precedence">
				<p>Operator precedence describes the order in which operations are performed in an arithmetic expression.</p>
				<c>var x = 100 + 50 * 3;</c>
				<p>As in traditional mathematics, the multiplication is done first. Multiplication (<c>*</c>) and division (<c>/</c>) have higher <b>precedence</b> than addition (<c>+</c>) and subtraction (<c>-</c>).</p>
				<p>The precedence can be changed by using parentheses:</p>
				<c>var x = (100 + 50) * 3;</c>
				<p>When using parentheses, the operations inside the parentheses are computed first.</p>
				<p>When many operations have the same precedence (like addition and subtraction), they are computed from left to right:</p>
				<c>var x = 100 + 50 - 3;</c>
			</s>
			<s name="Operator precedence values">
				<t>
					<h>
						<c width="100">Value</c>
						<c width="100">Operator</c>
						<c>Description</c>
						<c>Example</c>
					</h>
					<r>
						<c>21</c>
						<c><c>()</c></c>
						<c>Expression grouping</c>
						<c><c>(3 + 4)</c></c>
					</r>
					<r>
						<c>20</c>
						<c><c>.</c></c>
						<c>Member</c>
						<c><c>person.name</c></c>
					</r>
					<r>
						<c>20</c>
						<c><c>[]</c></c>
						<c>Member</c>
						<c><c>person["name"]</c></c>
					</r>
					<r>
						<c>19</c>
						<c><c>()</c></c>
						<c>Function call</c>
						<c><c>func()</c></c>
					</r>
					<r>
						<c>19</c>
						<c><c>new</c></c>
						<c>Create</c>
						<c><c>new StringBuilder()</c></c>
					</r>
					<r>
						<c>18</c>
						<c><c>++</c></c>
						<c>Prefix increment</c>
						<c><c>++x</c></c>
					</r>
					<r>
						<c>18</c>
						<c><c>--</c></c>
						<c>Prefix decrement</c>
						<c><c>--x</c></c>
					</r>
					<r>
						<c>17</c>
						<c><c>++</c></c>
						<c>Postfix increment</c>
						<c><c>x++</c></c>
					</r>
					<r>
						<c>17</c>
						<c><c>--</c></c>
						<c>Postfix decrement</c>
						<c><c>x--</c></c>
					</r>
					<r>
						<c>16</c>
						<c><c>!</c></c>
						<c>Logical not</c>
						<c><c>!x</c></c>
					</r>
					<r>
						<c>15</c>
						<c><c>~</c></c>
						<c>Bitwise not</c>
						<c><c>~x</c></c>
					</r>
					<r>
						<c>14</c>
						<c><c>+</c></c>
						<c>Unary plus</c>
						<c><c>+x</c></c>
					</r>
					<r>
						<c>14</c>
						<c><c>-</c></c>
						<c>Unary minus</c>
						<c><c>-x</c></c>
					</r>
					<r>
						<c>13</c>
						<c><c>-&gt;</c></c>
						<c>Inherit</c>
						<c><c>A -&gt; { }</c></c>
					</r>
					<r>
						<c>12</c>
						<c><c>*</c></c>
						<c>Multiplication</c>
						<c><c>10 * 5</c></c>
					</r>
					<r>
						<c>12</c>
						<c><c>/</c></c>
						<c>Division</c>
						<c><c>10 / 5</c></c>
					</r>
					<r>
						<c>12</c>
						<c><c>%</c></c>
						<c>Modulo (remainder)</c>
						<c><c>17 % 10</c></c>
					</r>
					<r>
						<c>11</c>
						<c><c>+</c></c>
						<c>Addition</c>
						<c><c>2 + 3</c></c>
					</r>
					<r>
						<c>11</c>
						<c><c>-</c></c>
						<c>Subtraction</c>
						<c><c>5 - 2</c></c>
					</r>
					<r>
						<c>10</c>
						<c><c>&lt;&lt;</c></c>
						<c>Shift left</c>
						<c><c>x &lt;&lt; 2</c></c>
					</r>
					<r>
						<c>10</c>
						<c><c>&gt;&gt;</c></c>
						<c>Shift right</c>
						<c><c>x &gt;&gt; 2</c></c>
					</r>
					<r>
						<c>10</c>
						<c><c>&gt;&gt;&gt;</c></c>
						<c>Shift right (unsigned)</c>
						<c><c>x &gt;&gt;&gt; 2</c></c>
					</r>
					<r>
						<c>9</c>
						<c><c>&amp;</c></c>
						<c>Bitwise and</c>
						<c><c>x &amp; y</c></c>
					</r>
					<r>
						<c>8</c>
						<c><c>^</c></c>
						<c>Bitwise xor</c>
						<c><c>x ^ y</c></c>
					</r>
					<r>
						<c>7</c>
						<c><c>|</c></c>
						<c>Bitwise or</c>
						<c><c>x | y</c></c>
					</r>
					<r>
						<c>6</c>
						<c><c>&lt;</c></c>
						<c>Less than</c>
						<c><c>x &lt; y</c></c>
					</r>
					<r>
						<c>6</c>
						<c><c>&lt;=</c></c>
						<c>Less than or equal</c>
						<c><c>x &lt;= y</c></c>
					</r>
					<r>
						<c>6</c>
						<c><c>&gt;</c></c>
						<c>Greater than</c>
						<c><c>x &gt; y</c></c>
					</r>
					<r>
						<c>6</c>
						<c><c>&gt;</c></c>
						<c>Greater than or equal</c>
						<c><c>x &gt;= y</c></c>
					</r>
					<r>
						<c>5</c>
						<c><c>==</c></c>
						<c>Equal</c>
						<c><c>x == y</c></c>
					</r>
					<r>
						<c>5</c>
						<c><c>!=</c></c>
						<c>Not equal</c>
						<c><c>x != y</c></c>
					</r>
					<r>
						<c>4</c>
						<c><c>&amp;&amp;</c></c>
						<c>Logical and</c>
						<c><c>x &amp;&amp; y</c></c>
					</r>
					<r>
						<c>3</c>
						<c><c>||</c></c>
						<c>Logical or</c>
						<c><c>x || y</c></c>
					</r>
					<r>
						<c>2</c>
						<c><c>?</c></c>
						<c>Ternary operator</c>
						<c><c>a ? b : c</c></c>
					</r>
					<r>
						<c>1</c>
						<c><c>=</c></c>
						<c>Assign</c>
						<c><c>x = y</c></c>
					</r>
					<r>
						<c>1</c>
						<c><c>+=</c></c>
						<c>Assign by</c>
						<c><c>x += y</c></c>
					</r>
					<r>
						<c>1</c>
						<c><c>-=</c></c>
						<c>Assign by</c>
						<c><c>x -= y</c></c>
					</r>
					<r>
						<c>1</c>
						<c><c>*=</c></c>
						<c>Assign by</c>
						<c><c>x *= y</c></c>
					</r>
					<r>
						<c>1</c>
						<c><c>/=</c></c>
						<c>Assign by</c>
						<c><c>x *= y</c></c>
					</r>
					<r>
						<c>1</c>
						<c><c>%=</c></c>
						<c>Assign by</c>
						<c><c>x %= y</c></c>
					</r>
					<r>
						<c>1</c>
						<c><c>&lt;&lt;=</c></c>
						<c>Assign by</c>
						<c><c>x &lt;&lt;= y</c></c>
					</r>
					<r>
						<c>1</c>
						<c><c>&gt;&gt;=</c></c>
						<c>Assign by</c>
						<c><c>x &gt;&gt;= y</c></c>
					</r>
					<r>
						<c>1</c>
						<c><c>&gt;&gt;&gt;=</c></c>
						<c>Assign by</c>
						<c><c>x &gt;&gt;&gt;= y</c></c>
					</r>
					<r>
						<c>1</c>
						<c><c>&amp;=</c></c>
						<c>Assign by</c>
						<c><c>x &amp;= y</c></c>
					</r>
					<r>
						<c>1</c>
						<c><c>^=</c></c>
						<c>Assign by</c>
						<c><c>x ^= y</c></c>
					</r>
					<r>
						<c>1</c>
						<c><c>|=</c></c>
						<c>Assign by</c>
						<c><c>x |= y</c></c>
					</r>
				</t>
			</s>
		</s>
		<s name="Assignment">
			<p>The <c>=</c> assignment operator assigns a value to a variable.</p>
			<c>var x = 10; // 10</c>
			<p>The <c>+=</c> assignment operator adds a value to a variable.</p>
			<c><![CDATA[
				var x = 10;
				x += 5; // 15 ]]>
			</c>
			<p>The <c>-=</c> assignment operator subtracts a value from a variable.</p>
			<c><![CDATA[
				var x = 10;
				x -= 5; // 5 ]]>
			</c>
			<p>The <c>*=</c> assignment operator multiplies a variable.</p>
			<c><![CDATA[
				var x = 10;
				x *= 5; // 50 ]]>
			</c>
			<p>The <c>/=</c> assignment operator divides a variable.</p>
			<c><![CDATA[
				var x = 10;
				x /= 5; // 2 ]]>
			</c>
			<p>The <c>%=</c> assignment operator assigns a remainder to a variable.</p>
			<c><![CDATA[
				var x = 17;
				x %= 10; // 7 ]]>
			</c>
		</s>
		<s name="Data types">
			<p>Goat variables can hold many data types: numbers, strings, objects and more:</p>
			<c>	<![CDATA[
				var length = 16; // Integer
				var price = 11.99; // Real
				var name = "Ivan"; // String
				var obj = {name: "Ivan", age: 33}; // Object
				x %= 10; // 7 ]]>
			</c>
			<s name="Concept">
				<p>In programming, data types is an important concept. To be able to operate on variables, it is important to know something about the type.</p>
				<p>For example, when adding a number and a something, the Goat interpreter will treat the second operator as a number:</p>
				<c>var x = 2 + 3; // result is: 5</c>
				<p>But, when adding a string and a something, the Goat interpreter will treat the second operator as a string. If the second operator is not a string, the interpreter will convert it to the string:</p>
				<c>var s = "text" + 123; // result is: "text123"</c>
				<p>The Goat interpreter evaluates expressions from left to right (but according to precedence).  Different sequences can produce different results:</p>
				<c><![CDATA[
					var s1 = "text" + 2 + 3; // result is: "text23"
					var s2 = "text" + (2 + 3); // result is: "text5"]]>
				</c>
			</s>
			<s name="Goat types are dynamic">
				<p>The Goat language has dynamic types. This means that the same variable can be used to hold different data types:</p>
				<c><![CDATA[
					var x; // 'x' is undefined
					x = 5; // now 'x' is a integer
					x = "Ivan"; // now 'x' is a string]]>
				</c>
			</s>
			<s name="Strings">
				<p>A string (or a text string) is a series of characters like "Abracadabra". Strings are written with double quotes:</p>
				<c>var name="Ivan";</c>
			</s>
			<s name="Chars">
				<p>Char is a single symbol. Chars are written with single quotes:</p>
				<c>var c = 'A';</c>
			</s>
			<s name="Integers">
				<p>A number without decimal point:</p>
				<c>var i = 10;</c>
			</s>
			<s name="Real numbers">
				<p>A number with decimal point (also, it called "floating-point number"):</p>
				<c>var r = 0.01;</c>
			</s>
			<s name="Booleans">
				<p>Booleans can only have two values: <c>true</c> or <c>false</c>:</p>
				<c><![CDATA[
					var t = true;
					var f = false;]]>
				</c>
				<p>Booleans are often used in conditional testing:</p>
				<c><![CDATA[
					var x = 5;
					var y = 5;
					var z = 6;
					var t = (x == y); // true
					var f = (x == z); // false]]>
				</c>
			</s>
			<s name="Arrays">
				<p>Goat arrays are written with square brackets. Array items are separated by commas. The following code declares (creates) an array called <c>herd</c>, containing three items (goats nicknames):</p>
				<c>var herd = ["Dirty", "Stinky", "Crazy"];</c>
				<p>Array indexes are zero-based, which means the first item is <c>[0]</c>, second is <c>[1]</c>, and so on.</p>
			</s>
			<s name="Objects">
				<p>Goat objects are written with curly braces. Object properties are written as <c>name: value</c> pairs, separated by commas.</p>
				<c>var goat = { name: "Stinky", wool: Color.WHITE, age: 3}; </c>
			</s>
			<s name="Undefined">
				<p>In the Goat language, a variable without a value, has the value <c>undefined</c>.</p>
				<c>var name; // value is undefined</c>
				<p>Any variable can be emptied, by setting the value to <c>undefined</c>.</p>
				<c>name = undefined;</c>
			</s>
			<s name="Null">
				<p>In the Goat language, <c>null</c> is "nothing". It is supposed to be something that doesn't exist. Any variable can be emptied, by setting the value to <c>null</c>.</p>
				<c>name = null;</c>
			</s>
			<p><c>null</c> is not <c>undefined</c>! <c>null</c> means: it defined, but the value of it is "nothing".</p>
		</s>
		<s name="Functions">
			<p>A Goat function is a block of code designed to perform a particular task. A Goat function is executed when "something" invokes it (calls it).</p>
			<c><![CDATA[
				var myFunction = function(a, b) {
					return a * b; // the function returns the product of 'a' and 'b'
				};]]>
			</c>
			<p>Why Functions? You can reuse code: Define the code once, and use it many times. You can use the same code many times with different arguments, to produce different results.</p>
			<s name="Syntax">
				<p>A Goat function is defined with the <c>function</c> keyword, followed by parentheses (). The parentheses may include parameter names separated by commas: <c>(parameter_1, parameter_2, ...)</c>. The code to be executed, by the function, is placed inside curly brackets: <c>{}</c>. To name a function (for the ability of invocation), the function object needs to be written to a variable:</p>
				<c><![CDATA[
					var name = function(parameter_1, parameter_2, parameter_3) {
						//code to be executed
					};]]>
				</c>
				<p>In the Goat language, the <c>function</c> keyword (it is long and is used very often ) can be changed to a dollar sign <c>$</c>:</p>
				<c><![CDATA[
					var name = $(parameter_1, parameter_2, parameter_3) {
						//code to be executed
					};]]>
				</c>
				<p>Function <b>parameters</b> are listed inside the parentheses <c>()</c> in the function definition. Function <b>arguments</b> are the <b>values</b> received by the function when it is invoked. Inside the function, the arguments (the parameters) behave as local variables.</p>
			</s>
			<s name="Return">
				<p>When the Goat interpreter reaches a <b>return statement</b>, the function will stop executing, then the interpreter will "return" to execute the code after the invoking statement. Functions often compute a return value. The return value is "returned" back to the "caller":</p>
				<c><![CDATA[
					var myFunction = function(a, b) {
						return a * b; // the function returns the product of 'a' and 'b'
					};
					
					var x = myFunction(4, 3);]]>
				</c>
				<p>The result in <c>x</c> will be <c>12</c>.</p>
			</s>
			<s name="Invocation">
				<p>The <c>()</c> operator invokes the function.</p>.
				<p>To invoke a function without arguments, use empty operator:</p>
				<c><![CDATA[
					var doSomething = function() {
						//...
					};
					
					//...
					
					doSomething();]]>
				</c>
				<p>To invoke a function with arguments, place arguments, separated by comma, inside the <c>()</c> operator: </p>
				<c><![CDATA[
					var doSomething = function(a, b, c) {
						//...
					};
					
					//...
					
					doSomething("test", 3.14, false);]]>
				</c>
				<p>Argument can be any expression - string, number, another function call etc.</p>
			</s>
			<s name="Built-in functions">
				<p>The Goat language has a lot of built-in functions (so-called built-in library). This library provides type definitions and functions for tasks such as string handling, mathematical computations, input/output processing and several other operating system services.</p>
				<p>For example, the <c>print</c> function converts the first argument to a string and outputs it to a console:</p>
				<c>print(2 + 3); // outputs: 5</c>
				<p><d>Built-in functions are fully described in the appropriate chapter.</d></p>
			</s>
		</s>
		<s name="Objects">
			<s name="Real life objects, properties and methods">
				<p>In real life, a car is an <b>object</b>. A car has <b>properties</b> like weight and color, and <b>methods</b> like start and stop.</p>
				<p>Object:</p>
				<c>var car = {};</c>
				<p>Properties:</p>
				<c><![CDATA[
					car.name = "Fiat";
					car.model = 500;
					car.weight = "850kg";
					car.color = "white";]]>
				</c>
				<p>Methods:</p>
				<c><![CDATA[
					car.start();
					car.drive();
					car.brake();
					car.stop();]]>
				</c>
				<p>All cars have the same <b>properties</b>, but the property values differ from car to car.</p>
				<p>All cars have the same <b>methods</b>, but the methods are performed at different times.</p>
			</s>
			<s name="Goat objects">
				<p>Recall that Goat variables are containers for data values. This code assigns a simple value ("Fiat") to a variable named <c>car</c>:</p>
				<c>var car = "Fiat";</c>
				<p>Objects are variables too. But objects can contain many values. This code assigns <b>many values</b> ("Fiat", 500, "white") to a <b>variable</b> named car:</p>
				<c>var car = {type: "Fiat", model: 500, color:"white"};</c>
				<p>The values are written as <c>name:value</c> pairs (name and value separated by a colon).</p>
			</s>
			<s name="Properties">
				<p>The <c>name:values</c> pairs (in Goat objects) are called properties.</p>
				<c>var goat = { name: "Stinky", wool: Color.WHITE, age: 3 };</c>
				<t>
					<h>
						<c width="100">Property</c>
						<c>Value</c>
					</h>
					<r>
						<c>name</c>
						<c>"Stinky"</c>
					</r>
					<r>
						<c>wool</c>
						<c>Color.WHITE</c>
					</r>
					<r>
						<c>age</c>
						<c>3</c>
					</r>
				</t>
			</s>
			<s name="Methods">
				<p>Methods are <b>actions</b> that can be performed on objects. Methods are stored in properties as <b>function definitions.</b> In other words, methods are functions that are performed on an object.</p>
				<c><![CDATA[
					var person = {
						firstName : "Scott",
						lastName : "Cameron",
						age : 45,
						
						fullName : function() {
							return firstName + ' ' + lastName;
						}
					};
					
					var name = person.fullName(); // result is: "Scott Cameron"]]>
				</c>
			</s>
			<s name="Definition">
				<p>You define (and create) a Goat object with an object literal:</p>
				<c>var person = { firstName : "Scott", lastName : "Cameron", age : 45 };</c>
				<p>Spaces and line breaks are not important. An object definition can span multiple lines:</p>
				<c><![CDATA[
					var person = {
						firstName : "Scott",
						lastName : "Cameron",
						age : 45
					};]]>
				</c>
			</s>
			<s name="Accessing object properties">
				<p>You can access object properties in two ways:</p>
				<c>objectName.propertyName</c>
				<p>or</p>
				<c>objectName["propertyName"]</c>
				<p>For example,</p>
				<c>person.lastName</c>
				<p>or</p>
				<c>person["lastName"];</c>
			</s>
			<s name="Accessing object methods">
				<p>You access an object method with the following syntax:</p>
				<c>objectName.methodName()</c>
				<p>For example,</p>
				<c>name = person.fullName();</c>
			</s>
			<s name="Nested objects">
				<p>Properties can be not only strings and numbers, but also arrays and objects:</p>
				<c><![CDATA[
					var person = {
						firstName : "Scott",
						lastName : "Cameron",
						age : 45,
						children: [
							{ firstName: "Ann", lastName: "Cameron", age: 10 },
							{ firstName: "Dave", lastName: "Cameron", age: 14 }
						]
					};]]>
				</c>
				<p>Thus, objects can be unlimitedly nested within each other.</p>
			</s>
		</s>
		
	</s>
	
	<s name="In comparison with JavaScript">
		<p>The Goat programming language based in general on JavaScript, but it has some differences.</p>
		<l>
			<i>The interpreter (engine) of the programming language is not a complement to the existing solutions, say, V8. It is completely developed from scratch. The interpreter is very small program and can be compiled and started in different platforms. I tried  Windows and Linux (both x86 and ARM). All you need are C++11 compiler and standard C library (libc etc).</i>
			<i>Programs are launched not in a browser, not in a special environment (say Node.js); you can write general-purpose applications. Easy to install: just copy the file with your code and interpreter and then start.</i>
			<i>The syntax is more simple, the object model is more unified.</i>
			<i>Goat language supports multi-threading and operators overloading.</i>
			<i>You can create an object from more than one prototype.</i>
		</l>
		<p>Some samples are below.</p>
		
		<s name="Identifiers">
			<h name="JavaScript">
				<p>The first character of an identifier must be a letter, or an underscore (<c>_</c>), or a dollar sign (<c>$</c>). Subsequent characters may be letters, digits, underscores, or dollar signs.</p>
			</h>
			<h name="Goat">
				<p>The first character must be a letter or an underscore (<c>_</c>). Subsequent characters may be letters, digits or underscores.</p>
				<p>Dollar sign used as a short replacement of <c>function</c> keyword:</p>
				<c>var f = $(a, b) { };</c>
				<p>it's the same as:</p>
				<c>var f = function(a, b) { };</c>
			</h>
		</s>
		
		<s name="Keywords">
			<p>The Goat programming language reserves several additional keywords:</p>
			<t>
				<h>
					<c>Keyword</c>
					<c>Description</c>
				</h>
				<r>
					<c><c>thread</c></c>
					<c>Declares a thread</c>
				</r>
				<r>
					<c><c>import</c></c>
					<c>Imports a source file</c>
				</r>
				<r>
					<c><c>debug</c>(instead of <c>debugger</c>)</c>
					<c>Stops the execution of Goat script, and switch the interpreter to debug (step-by-step) mode</c>
				</r>
			</t>
		</s>
		
		<s name="Operators">
			<p>The Goat language has no comparison operators <c>===</c> (equal value and equal type) and <c>!==</c> (not equal value or not equal type). Operators <c>==</c> and <c>!=</c> works in most cases as <c>===</c> and <c>!==</c> operators in JavaScript.</p>
			<p>The Goat language has not <c>typeof</c> and <c>instanceof</c> operators. Use <c>instanceOf</c> method instead:</p>
			<c>print(13.instanceOf(Integer)); // output: "true"</c>
			<p>The Goat language provides the new operator <c>-&gt;</c> that means inheritance.</p>
		</s>
		
		<s name="Primitive types">
			<h name="JavaScript">
				A primitive data type is a data that is not an object and has no methods. There are 6 primitive data types: string, number, boolean, null, undefined, symbol. All primitives are immutable.
			</h>
			<h name="Goat">
				<p>There are no primitive types. All data represented as objects. Each object except <c>undefined</c> has some methods. There are some predefined objects which are prototypes for primitive data, such as numbers or strings: <c>Char</c>, <c>String</c>, <c>Integer</c>, <c>Real</c>, <c>Boolean</c> and <c>Null</c>.</p>
				<p>This programming language clearly distinguishes between strings (prototype is <c>String</c>) and individual characters (prototype is <c>Char</c>), as well as integers (<c>Integer</c>) and floating-point numbers (<c>Real</c>). These types have different set of methods and operators, but if necessary type can be converted to another:</p>
				<c><![CDATA[
					var c = 'a'; // prototype of c is Char
					var s = String.valueOf(c); // conversion to String]]>
				</c>
				<p>All other structures, for example, functions, threads, arrays etc have own prototypes (<c>Function</c>, <c>Thread</c>, <c>Array</c>).</p>
			</h>
		</s>
		
		<s name="Scope">
			<h name="JavaScript">
				<p>There are two types of scopes: global and local. Variables defined inside a function are in the local scope. Variables defined inside of a block statement will remain in the scope they were already in. ECMAScript 6 introduced the <c>let</c> keyword. Contrary to the <c>var</c> keyword, the <c>let</c> keyword supports the declaration of local scope inside block statements.</p>
				<c><![CDATA[
					var func = function() {
						var v = 0;
						// do something...
						if (true) {
							let v = 1; // local declaration
						}
					};]]>
				</c>
				<p>If you re-declare a JavaScript variable in the same block, it will not lose its value.</p>
			</h>
			<h name="Goat">
				<p>There is no global scope. You can re-declare variable with the same name in inner block statement, it will be used only in this block.</p>
				<c><![CDATA[
					var func = $() {
						var v = 0;
						if (true) {
							var v = 1;
							print(v); // output: "1"
						}
						print(v); // output: "0"
					};]]>
				</c>
				<p>But, if you re-declare a Goat variable in the same block, it will lose its value.</p>
			</h>
		</s>
		
		<s name="Operators overloading">
			<h name="JavaScript">
				<p>Doesn't support.</p>
			</h>
			<h name="Goat">
				<p>You can use the operator as method name:</p>
				<c><![CDATA[
					var Vector = {
						init : $(x, y) {
							this.x = x; this.y = y
						},
						toString : $() {
							return "X: " + x + ", Y: " + y;
						},
						"+" : $(vec) {
							return new Vector(x + vec.x, y + vec.y);
						},
						"*" : $(val) {
							return new Vector(x * val, y * val);
						}
					};

					var v1 = new Vector(100, 200);
					var v2 = new Vector(200, 400);

					print((v1 + v2).toString()); // output: "X: 300, Y: 600"
					print(' ');
					print((v1 * 5).toString()); // output: "X: 500, Y: 1000";]]>
				</c>
			</h>
		</s>
		
		<s name="Multithreading">
			<h name="JavaScript">
				<p>Doesn't support. There are some workarounds, say web workers, and, of course, functions <c>setTimeout()</c> and <c>setInterval()</c>.</p>
			</h>
			<h name="Goat">
				<p>There is <c>thread</c> keyword. It possible to declare any function as a separate thread.</p>
				<c><![CDATA[
					var t0 = thread(){
						while(true) {
							print('A');
						}
					};

					var t1 = thread(){
						while(true) {
							print('B');
						}
					};

					t0.run();
					t1.run();

					// Output: "ABABABABABABAB...."]]>
				</c>
			</h>
		</s>

		<s name="'new' keyword and constructors">
			<h name="JavaScript">
				<p>Constructors are like regular functions, but we use them with the <c>new</c> keyword. If you inherit your object and the parent has a constructor, you need to call parent constructor to perform initialization logic.</p>
				<c><![CDATA[
					var A = function() {
						// init something...
					};

					var B = function() {
						A.apply(this);
						// init something else...
					};
					B.prototype = new A();]]>
				</c>
			</h>
			<h name="Goat">
				<p>There is special method <c>init()</c>. If method defined, interpreter call it. If method also defined in base object, interpreter call it first (order of calling constructors as in C++).</p>
				<c><![CDATA[
					var A = {
						init : $() {
							// init something...
						}
					};

					var B = A -> {
						init : $() {
							// init something else...
						}
					};

					var obj = new B(); /* both init method will be called,
										  first from A, second from B */]]>
				</c>
			</h>
		</s>

		<s name="Inheritance">
			<h name="JavaScript">
				<c><![CDATA[
					var A = function() {
						this.x = 0;
					};

					var B = function() {
						A.apply(this);
						this.y = 1;
					};
					B.prototype = new A();

					var C = function() {
						B.apply(this);
						this.z = 2;
					};
					C.prototype = new B();]]>
				</c>
				<p>Nearly all objects in JavaScript are instances of <c>Object</c>, a typical object inherits properties (including methods) from <c>Object.prototype</c>.</p>
			</h>
			<h name="Goat">
				<p>The syntax is much simpler. Use operator <c>-&gt;</c>:</p>
				<c><![CDATA[
					var A = {
						x : 0
					};

					var B = A -> {
						y : 1
					};

					var C = B -> {
						z : 2
					};]]>
				</c>
				<p>Goat language has not class (prototype) named <c>Object</c> (is the root of the class hierarchy in Java and prototype hierarchy in JavaScript). Objects have not a super-prototype. An object has prototype if it created from literal (for example, strings), or it created by new keyword, or if prototype(s) is explicitly specified when creating an object:</p>
				<c><![CDATA[
					var A = { }; // A has no prototypes 
					var S = "hello"; // the prototype of 'S' is 'String'
					var B = new A(); // the prototype of 'B' is 'A'
					var C = B->{ }; // the prototype of 'C' is 'B']]>
				</c>
			</h>
		</s>
		
		<s name="Multiple inheritance">
			<h name="JavaScript">
				<p>Is not supported. You can use some tricks (say mixins) but it is not true multiple inheritance.</p>
			</h>
			<h name="Goat">
				<p>Why not.</p>
				<c><![CDATA[
					var A = {
						x : 0
					};

					var B = {
						y : 1
					};

					var C = [A, B] -> {
						z : 2
					};]]>
				</c>
				<p>The solution of the problem of multiple inheritance ("the diamond problem"): Goat uses the list of prototypes to inherit from as an ordered list. The interpreter uses the first method it finds by depth-first searching.</p>
			</h>
		</s>	
	</s>
</goat>
