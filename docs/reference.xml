<goat>
	<v value="0.2 &quot;Goatling&quot;"/>
	<s name="Introduction">
		<p><b>Goat</b> is a high-level, dynamic, weakly typed, prototype-based, multi-paradigm, and interpreted programming language, based on JavaScript. It supports the basic functionality of JavaScript, but in addition, it adds support for multithreading, multiple inheritance, operator overloading (all as in C ++), simplified syntax, and so on.</p>
		<p>Why "Goat"? At first, I wanted to name this programming language as "Go", but unfortunately, some little-known company (it seems "Google" or something like that) has already developed a programming language with that name. After a while, when I programmed this interpreter on a laptop lying in a hammock, I was suddenly bitten by my goat. I thought that once the name "Go" is occupied, then perhaps the name "Goat" is no worse. I immediately named the project folder this name and since then it has not changed.</p>
	</s>
	
	<s name="Where to download the latest release">
		<p>On GitHub: <url>https://github.com/kniazkov/goat/releases/latest</url>.</p>
	</s>
	
	<s name="How to launch Goat script">
		<s name="Quick start">
			<p>Just download the executable file, open console, type executable name and specify a script file name as a parameter:</p>
			<c>goat.exe program.goat</c>
		</s>
		<s name="Command line parameters">
			<p>The Goat interpreter parses command line arguments as follows. All arguments started with two hyphens are internal parameters of the interpreter ("options"). The first argument which is not an option is the name of the script file. All next arguments send to script.</p>
			<p>For example,</p>
			<c>goat.exe --lib=../lib program.goat arg1 arg2</c>
			<p>or, the same thing:</p>
			<c>goat.exe program.goat --lib=../lib arg1 arg2</c>
			<p>or:</p>
			<c>goat.exe program.goat arg1 arg2 --lib=../lib</c>
			<p>where: <c>goat.exe</c> is Goat executable, <c>program.goat</c> is name of the script, <c>--lib=../lib</c> is option of the interpterer, <c>arg1</c> and <c>arg2</c> are arguments of the script.</p>
			<p>Here is a list of interpreter options:</p>
			<h name="--lib">
				<p>Path (paths) to external libraries (to importable files). For example, a path to the Goat standard library. Several paths can be separated by a semicolon.</p>
				<c>goat.exe program.goat --lib=c:\goat\lib;c:\project</c>
				<p>Note about path delimiting character, this is most commonly the slash ("/") or the backslash  ("\"). While the interpreter parsed paths, it changes delimiting characters to the character used in the current platform. Say, for Windows, all delimiter characters replaced to the backslash, and for Linux (Unix) - to slash. So path <c>--lib=..\folder\lib</c> interpreted as well as path <c>--lib=../folder/lib</c>, for all platforms.</p>
			</h>
			<h name="--debug">
				<p>The Goat interpreter launched in debug mode. It means that interpretation will stop and set step-by-step mode when the interpreter executes <c>debug;</c> statement.</p>
			</h>
			<h name="--gc">
				<p>One of three modes of garbage collection. <c>--gc=serial</c> enable serial mode, it means that the garbage collector periodically stops all threads (but it takes low processor resources for collection and has small memory overhead). <c>--gc=parallel</c> does not stop threads (but it constantly uses some processor resources and also it uses some extra memory), this mode enabled by default. <c>--gc=debug</c> used for debugging purposes for interpreter developer, it calls collector after each statement of a script and this is <b>very</b> slow.</p>
				<p>If you don't know what "garbage collection" means, please do not use this parameter, parallel collector is okay for most purposes.</p>
			</h>
		</s>
	</s>
	
	<s name="Basics">
		<p><b>Important note. A significant part of this chapter is the redesigned tutorial from: <url>https://www.w3schools.com/js/default.asp</url>. Since the Goat language is the modified JavaScript language, so the description of the Goat language is the modified description of the  Javascript language. Any coincidences are NOT random.</b></p>
		<s name="Hello world">
			<p>Create a new file, say <c>hello_world.goat</c> (file extension does not matter) containing one line:</p>
			<c>print("Hello, world!");</c>
			<p>and then launch it:</p>
			<c>goat.exe hello_world.goat</c>
			<p>That's all. The interpreter will start the script and will print <c>Hello, world!</c> to the console.</p>
		</s>
		<s name="Internationalization and localization">
			<p>It possible to use any Unicode characters in string literals. The Goat interpreter parses source files in UTF-8  format. Output stream also encoded to UTF-8. The previous example, but contains some "special" symbols:</p>
			<c>print("Bonjour, réalité cruelle et ingrate!");</c>
		</s>
		<s name="Program and statements">
			<s name="Program">
				<p>A computer program is a list of "instructions" to be "executed" by a computer. In a programming language, these programming instructions are called <b>statements.</b></p>
				<p>A <b>Goat program is a list of</b> programming <b>statements.</b></p>
				<c><![CDATA[
					var x, a, b; // statement 1
					a = 2; // statement 2
					b = 3; //       ... 3
					x = a + b; //       ... 4
					print(x); //       ... 5]]>
				</c>
				<p>Goat programs are executed by the Goat interpreter.</p>
			</s>
			<s name="Statements">
				<p>Goat statements are composed of: <b>Values</b>, <b>Operators</b>, <b>Expressions</b>, <b>Keywords</b>, and <b>Comments</b>.</p>
				<p>The statements are executed, one by one, in the same order as they are written.</p>
			</s>
			<s name="Semicolons">
				<p>Semicolons <c>;</c> separate Goat statements. Add a semicolon at the end of each executable statement:</p>
				<c><![CDATA[
					var x, a, b; // declare 3 variables
					a = 2; // assign the value 2 to 'a'
					b = 3; // assign the value 6 to 'b'
					x = a + b; // assign the sum of 'a' and 'b' to 'x'
					print(x); // print value of 'x']]>
				</c>
				<p>When separated by semicolons, multiple statements on one line are allowed:</p>
				<c>a = 2; b = 3; x = a + b;</c>
				<p>Though ending statements with a semicolon is not required, but highly recommended. This example is correct:</p>
				<c>print(2 + 3) // no semicolon at the end</c>
			</s>
			<s name="White space">
				<p>Goat parse tabulations and line breaks as white spaces. Goat ignores multiple spaces. You can add white space to your script to make it more readable. The following statements are equivalent:</p>
				<c><![CDATA[
					var a, b = 0;
					var a, b=0;
					var a,
						b = 0;]]>
				</c>
			</s>
			<s name="Code blocks">
				<p>Goat statements can be grouped together in code blocks, inside curly brackets <c>{...}</c>. The purpose of code blocks is to define statements to be executed together. One place you will find statements grouped together in blocks, is in Goat functions:</p>
				<c><![CDATA[
					var f = $(a, b) {
						var x;
						var y;
						x = a + b;
						y = a - b;
						print("summ: " + x + ", diff: " + y);
					};]]>
				</c>
			</s>
			<s name="Keywords and keyword sequences">
				<p>Goat statements often start with a keyword to identify the Goat action to be performed. Here is a list of the keywords (or keyword sequences):</p>
				<t>
					<h>
						<c width="180">Keyword</c>
						<c>Description</c>
					</h>
					<r>
						<c><c>var</c></c>
						<c>Declares a variable</c>
					</r>
					<r>
						<c><c>function</c> or <c>$</c></c>
						<c>Declares a function (method)</c>
					</r>
					<r>
						<c><c>thread</c></c>
						<c>Declares a thread</c>
					</r>
					<r>
						<c><c>return</c></c>
						<c>Exits a function (method)</c>
					</r>
					<r>
						<c><c>if</c>..<c>else if</c>..<c>else</c></c>
						<c>Marks a block of statements to be executed, depending on a condition</c>
					</r>
					<r>
						<c><c>switch</c>(<c>case</c>, <c>default)</c></c>
						<c>Marks a block of statements to be executed, depending on different cases</c>
					</r>
					<r>
						<c><c>for</c>(<c>in</c>)</c>
						<c>Marks a block of statements to be executed, as long as a condition is true</c>
					</r>
					<r>
						<c><c>while</c>, <c>do</c>..<c>while</c></c>
						<c>Executes a block of statements, and repeats the block, while a condition is true</c>
					</r>
					<r>
						<c><c>break</c></c>
						<c>Terminates a switch or a loop</c>
					</r>
					<r>
						<c><c>continue</c></c>
						<c>Jumps out of a loop and starts at the top</c>
					</r>
					<r>
						<c><c>try</c>..<c>catch</c>..<c>finally</c></c>
						<c>Implements error handling to a block of statements</c>
					</r>
					<r>
						<c><c>throw</c></c>
						<c>Throws an exception</c>
					</r>
					<r>
						<c><c>new</c></c>
						<c>Creates a new object</c>
					</r>
					<r>
						<c><c>import</c></c>
						<c>Imports a source file</c>
					</r>
					<r>
						<c><c>debug</c></c>
						<c>Stops the execution of Goat script, and switch the interpreter to debug (step-by-step) mode</c>
					</r>
				</t>
				<p>Goat keywords are reserved words. Reserved words cannot be used as names for variables.</p>
			</s>
		</s>
		<s name="Syntax">
			<p>Goat syntax is the set of rules, how Goat programs are constructed:</p>
			<c><![CDATA[
				var a, b, x; // How to declare variables
				a = 2; // How to assign values
				b = 3;
				x = a + b; // How to compute values
				print(x); // How to call functions
			]]>
			</c>
			<s name="Values">
				<p>The Goat syntax defines two types of values: fixed values and variable values. Fixed values are called <b>literals.</b> Variable values are called <b>variables.</b></p>
				<s name="Literals">
					<p>The most important rules for writing fixed values are:</p>
					<p><b>Integer numbers</b> are written without decimals:</p>
					<c>123</c>
					<p><b>Real numbers</b> are written with decimals, the decimal separator is a dot:</p>
					<c>0.001</c>
					<p><b>Strings</b> are text, written within double quotes:</p>
					<c>"Hello"</c>
					<p><b>Chars</b> are symbols written within single quotes:</p>
					<c>'A'</c>
				</s>
				<s name="Variables">
					<p>In a programming language, variables are used to store data values. Goat uses the <c>var</c> keyword to <b>declare</b> variables. An <b>equal sign</b> is used to <b>assign</b> values to variables.</p>
					<p>In this example, <c>x</c> is defined as a variable. Then, <c>x</c> is assigned (given) the value 10:</p>
					<c><![CDATA[
						var x;
						x = 10;]]>
					</c>
				</s>
			</s>
			<s name="Operators">
				<p>Goat uses <b>arithmetic operators</b> ( <c>+ - *  /</c> ) to <b>compute</b> values:</p>
				<c>(5 + 6) * 10</c>
				<p>Goat uses an <b>assignment operator</b> ( = ) to <b>assign</b> values to variables:</p>
				<c><![CDATA[
					var a, b;
					a = 2;
					b = 3;]]>
				</c>
			</s>
			<s name="Expressions">
				<p>An <b>expression</b> is a combination of literals, variables, function calls, other expression and operators, which computes to a value. The computation is called an evaluation. For example, 5 * 10 evaluates to 50:</p>
				<c>5 * 10</c>
				<p>Expressions can also contain variable values:</p>
				<c>x * 2</c>
				<p>...or function calls:</p>
				<c>x * sin(y)</c>
				<p>The values can be of various types, such as numbers and strings:</p>
				<c>"Hello" + ", " + "world"</c>
			</s>
			<s name="Identifiers">
				<p><b>Identifiers</b> are names.</p>
				<p>In Goat, identifiers are used to name variables. The rules for legal names are much the same in most programming languages. In Goat, the first character must be a letter or an underscore (<c>_</c>). Subsequent characters may be letters, digits or underscores. Numbers are not allowed as the first character.</p>
			</s>
			<s name="Case sensitive">
				<p>All Goat identifiers are case sensitive. The variables <c>maxValue</c> and <c>maxvalue</c>, are two different variables.</p>
				<c><![CDATA[
					var maxValue, maxvalue;
					maxValue = 10;
					maxvalue = 0.1;]]>
				</c>
			</s>
		</s>
		<s name="Comments">
			<p>Goat comments can be used to explain Goat code, and to make it more readable. Goat comments can also be used to prevent execution when testing alternative code.</p>
			<s name="Single line comments">
				<p>Single line comments start with <c>//</c>. Any text between <c>//</c> and the end of the line will be ignored by Goat (will not be executed). This example uses a single-line comment before each code line:</p>
				<c><![CDATA[
					// Create object:
					var obj = {};
					// Add a field to the object:
					obj.value = 10; ]]>
				</c>
				<p>This example uses a single line comment at the end of each line to explain the code:</p>
				<c><![CDATA[
					var x = 5; // Declare x, give it the value of 5
					var y = x + 2;  // Declare y, give it the value of x + 2]]>
				</c>
			</s>
			<s name="Multi-line comments">
				<p>Multi-line comments start with <c>/*</c> and end with <c>*/</c>. Any text between <c>/*</c> and <c>*/</c> will be ignored by Goat. This example uses a multi-line comment (a comment block) to explain the code:</p>
				<c><![CDATA[
					/*
					The code below declares the function which calculates
					and print sum and difference of two arguments
					*/
					var f = $(a, b) {
						var x;
						var y;
						x = a + b;
						y = a - b;
						print("summ: " + x + ", diff: " + y);
					};]]>
				</c>
			</s>
			<s name="Using comments to prevent execution">
				<p>Using comments to prevent execution of code is suitable for code testing. Adding <c>//</c> in front of a code line changes the code lines from an executable line to a comment. This example uses <c>//</c> to prevent execution of one of the code lines:</p>
				<c><![CDATA[
					var person = {};
					person.name = "Ivan";
					//person.gender = "Male";
					person.age = 33;]]>
				</c>
				<p>This example uses a comment block to prevent execution of multiple lines:</p>
				<c><![CDATA[
					var person = {};
					person.name = "Ivan";
					/*
					person.gender = "Male";
					person.age = 33;
					*/]]>					
				</c>
			</s>
		</s>
		<s name="Variables">
			<p>Goat <b>variables</b> are containers for storing data values. In this example, <c>x</c>, <c>y</c>, and <c>z</c>, are variables:</p>
			<c><![CDATA[
				var x = 5;
				var y = 6;
				var z = x + y;]]>					
			</c>
			<s name="Identifiers">
				<p>All Goat variables must be identified with unique names. These unique names are called <b>identifiers.</b> Identifiers can be short names (like <c>x</c> and <c>y</c>) or more descriptive names (<c>age</c>, <c>sum</c>, <c>totalVolume</c>). The general rules for constructing names for variables (unique identifiers) are:</p>
				<l>
					<i>names can contain letters, digits and underscores;</i>
					<i>names must begin with a letter;</i>
					<i>names can also begin with <c>_</c>;</i>
					<i>names are case sensitive (<c>y</c> and <c>Y</c> are different variables);</i>
					<i>reserved words (like Goat keywords) cannot be used as names.</i>
				</l>
			</s>
			<s name="Data types">
				<p>Goat can handle many types of data. Goat variables can hold numbers like 100 and text values like "Hello". Basic data types are:</p>
				<p><b>Integer</b> number (without decimal character):</p>
				<c>var i = 10;</c>
				<p><b>Real</b> (floating-point) number:</p>
				<c>var r = 0.01;</c>
				<p><b>String:</b></p>
				<c>var s = "Hello";</c>
				<p><b>Char</b>(single symbol):</p>
				<c>var c = 'A';</c>
				<p>And <b>Boolean:</b></p>
				<c>var b = true;</c>
			</s>
			<s name="Declaring (creating) Goat variables">
				<p>Creating a variable in Goat is called "declaring" a variable. You declare a JavaScript variable with the <c>var</c> keyword:</p>
				<c>var name;</c>
				<p>After the declaration, the variable has no value (technically it has the value of <c>undefined</c>). To assign a value to the variable, use the equal sign:</p>
				<c>name = "Ivan";</c>
				<p>You can also assign a value to the variable when you declare it:</p>
				<c>var name = "Ivan";</c>
			</s>
			<s name="One statement, many variables">
				<p>You can declare many variables in one statement. Start the statement with <c>var</c> and separate the variables by comma:</p>
				<c>var name = "Ivan", age = 33, gender = "male";</c>
				<p>A declaration can span multiple lines:</p>
				<c><![CDATA[
					var name = "Ivan",
						age = 33,
						gender = "male";]]>
				</c>
			</s>
			<s name="Undefined">
				<p>Variables are often declared without a value. The value can be something that has to be calculated, or something that will be provided later, like user input. A variable declared without a value will have the value <c>undefined</c>.</p>
				<c>var name; // value of 'name' is undefined</c>
			</s>
			<s name="Re-declaring variables">
				<p>If you re-declare a Goat variable, it will lose its value.</p>
				<c><![CDATA[
					var name = "Ivan";
					// do something...
					var name; // now, value of 'name' if undefined]]>
				</c>
			</s>
			<s name="Arithmetic">
				<p>As with algebra, you can do arithmetic with Goat variables, using operators like <c>=</c> and <c>+</c>:</p>
				<c>var x = 5 + 2 + 3;</c>
				<p>You can also add strings, but strings will be concatenated:</p>
				<c>var s = "Hello" + ", " + "world!"</c>
				<p>Also try this. The Goat language will convert second operator to string if the first operator is string:</p>
				<c>var s = "Value is" + ' ' + 5;</c>
			</s>
		</s>
		<s name="Operators">
			<s name="Examples">
				<p>The <b>assignment</b> operator (<c>=</c>) assigns a value to a variable.</p>
				<c>var x = 10;</c>
				<p>The <b>addition</b> operator (<c>+</c>) adds numbers:</p>
				<c><![CDATA[
					var a = 2;
					var b = 3;
					var c = a + b;]]>
				</c>
				<p>The <b>multiplication</b> operator (<c>*</c>) multiplies numbers.</p>
				<c><![CDATA[
					var a = 2;
					var b = 3;
					var c = a * b;]]>
				</c>
			</s>
			<s name="Arithmetic operators">
				<p>Arithmetic operators are used to perform arithmetic on numbers:</p>
				<t>
					<h>
						<c width="100">Operator</c>
						<c>Description</c>
					</h>
					<r>
						<c><c>+</c></c>
						<c>Addition</c>
					</r>
					<r>
						<c><c>-</c></c>
						<c>Subtraction</c>
					</r>
					<r>
						<c><c>*</c></c>
						<c>Multiplication</c>
					</r>
					<r>
						<c><c>/</c></c>
						<c>Division</c>
					</r>
					<r>
						<c><c>%</c></c>
						<c>Modulus (remainder)</c>
					</r>
					<r>
						<c><c>++</c></c>
						<c>Increment</c>
					</r>
					<r>
						<c><c>--</c></c>
						<c>Decrement</c>
					</r>
				</t>
			</s>
			<s name="Assignment operators">
				<p>Assignment operators assign values to Goat variables. </p>
				<t>
					<h>
						<c width="100">Operator</c>
						<c width="100">Example</c>
						<c>Same as</c>
					</h>
					<r>
						<c><c>=</c></c>
						<c>x = y</c>
						<c></c>
					</r>
					<r>
						<c><c>+=</c></c>
						<c>x += y</c>
						<c>x = x + y</c>
					</r>
					<r>
						<c><c>-=</c></c>
						<c>x -= y</c>
						<c>x = x - y</c>
					</r>
					<r>
						<c><c>*=</c></c>
						<c>x *= y</c>
						<c>x = x * y</c>
					</r>
					<r>
						<c><c>/=</c></c>
						<c>x /= y</c>
						<c>x = x / y</c>
					</r>
					<r>
						<c><c>%=</c></c>
						<c>x %= y</c>
						<c>x = x % y</c>
					</r>
				</t>
				<p>The <b>addition assignment</b> operator (<c>+=</c>) adds a value to a variable.</p>
				<c><![CDATA[
					var x = 10;
					x += 5;]]>
				</c>
				<p>Value of <c>x</c> will be: <c>15</c></p>
			</s>
			<s name="String operators">
				<p>The <c>+</c> and <c>+=</c> operators can also be used to add (concatenate) strings.</p>
				<c><![CDATA[
					var a = "Hello";
					var b = "world";
					var s = a + ", " + b;]]>
				</c>
				<p>Value of <c>s</c> will be: <c>Hello, world!</c></p>
			</s>
			<s name="Adding strings and not-strings">
				<p>Adding two numbers, will return the sum, but adding a string and a not-string (number, symbol etc) will return a string:</p>
				<c><![CDATA[
					var x = 2 + 3;
					var s = "result is: " + x;]]>
				</c>
				<p>Value of <c>s</c> will be: <c>result is: 5</c></p>
			</s>
			<s name="Comparison operators">
				<t>
					<h>
						<c width="100">Operator</c>
						<c>Description</c>
					</h>
					<r>
						<c><c>==</c></c>
						<c>Equal to</c>
					</r>
					<r>
						<c><c>!=</c></c>
						<c>Not equal</c>
					</r>
					<r>
						<c><c>&gt;</c></c>
						<c>Greater than</c>
					</r>
					<r>
						<c><c>&lt;</c></c>
						<c>Less than</c>
					</r>
					<r>
						<c><c>&gt;=</c></c>
						<c>Greater than or equal to</c>
					</r>
					<r>
						<c><c>&lt;=</c></c>
						<c>Less than or equal to</c>
					</r>
					<r>
						<c><c>?</c></c>
						<c>Ternary operator</c>
					</r>
				</t>
			</s>
			<s name="Logical operators">
				<p>Logical operators work with binary (<c>Boolean</c>) type.</p>
				<t>
					<h>
						<c width="100">Operator</c>
						<c>Description</c>
					</h>
					<r>
						<c><c>&amp;&amp;</c></c>
						<c>Logical and</c>
					</r>
					<r>
						<c><c>||</c></c>
						<c>Logical or</c>
					</r>
					<r>
						<c><c>!</c></c>
						<c>Logical not</c>
					</r>
				</t>
			</s>
			<s name="Bitwise operators">
				<p>Bitwise operators work with <c>Integer</c> type.</p>
				<t>
					<h>
						<c width="100">Operator</c>
						<c>Description</c>
						<c>Example</c>
						<c>Same as</c>
						<c>Result</c>
						<c>Decimal</c>
					</h>
					<r>
						<c><c>&amp;</c></c>
						<c>And</c>
						<c>5 &amp; 1</c>
						<c>0101 &amp; 0001</c>
						<c>0001</c>
						<c>1</c>
					</r>
					<r>
						<c><c>|</c></c>
						<c>Or</c>
						<c>5 | 1</c>
						<c>0101 | 0001</c>
						<c>0101</c>
						<c>5</c>
					</r>
					<r>
						<c><c>~</c></c>
						<c>Not</c>
						<c>~5</c>
						<c>~0101</c>
						<c>...111010</c>
						<c>-6</c>
					</r>
					<r>
						<c><c>^</c></c>
						<c>Xor</c>
						<c>5 ^ 1</c>
						<c>0101 ^ 0001</c>
						<c>0100</c>
						<c>4</c>
					</r>
					<r>
						<c><c>&lt;&lt;</c></c>
						<c>Left shift</c>
						<c>5 &lt;&lt; 1</c>
						<c>0101 &lt;&lt; 1</c>
						<c>1010</c>
						<c>10</c>
					</r>
					<r>
						<c><c>&gt;&gt;</c></c>
						<c>Signed right shift</c>
						<c>5 &gt;&gt; 1</c>
						<c>0101 &gt;&gt; 1</c>
						<c>0010</c>
						<c>2</c>
					</r>
					<r>
						<c><c>&gt;&gt;&gt;</c></c>
						<c>Zero fill right shift</c>
						<c>5 &gt;&gt;&gt; 1</c>
						<c>0101 &gt;&gt;&gt; 1</c>
						<c>0010</c>
						<c>2</c>
					</r>
				</t>
			</s>
			<s name="Special operators">
				<t>
					<h>
						<c width="100">Operator</c>
						<c>Description</c>
					</h>
					<r>
						<c><c>-&gt;</c></c>
						<c>Inherit</c>
					</r>
				</t>
			</s>
			<s name="Common operators">
				<p>Each object supports these operators: <c>-&gt;</c> (inherit), <c>==</c> (equal), <c>!=</c> (not equal) and <c>!</c> (logical not).</p>
				<h name="-&gt; (inherit)">
					<p>Each object can be a prototype for a new object. Below in this document, it will be explained what is prototyping.</p>
				</h>
				<h name="== (equal) and != (not equal)">
					<p>In common case, an object equals to another object, if these objects are the same object. For numbers, strings, other built-in types, an object is equal to another object if these objects have the same value, for example, <c>5 == 2 + 3</c>.</p>
				</h>
				<h name="! (not)">
					<p>In common case, <c>not</c> object is <c>false</c>. The chapters about the comparison and conditions will describe how this is used.</p>
				</h>
			</s>
		</s>
		<s name="Arithmetic">
			<s name="Arithmetic Operations">
				<p>A typical arithmetic operation operates on two numbers. The two numbers can be literals:</p>
				<c>var x = 100 + 50;</c>
				<p>or variables:</p>
				<c>var x = a + b;</c>
				<p>or expressions:</p>
				<c>var x = (100 + 50) * a;</c>
			</s>
			<s name="Operators and operands">
				<p>The numbers (in an arithmetic operation) are called <b>operands.</b></p>
				<p>The operation (to be performed between the two operands) is defined by an <b>operator.</b></p>
				<t>
					<h>
						<c width="100">Operand</c>
						<c width="100">Operator</c>
						<c>Operand</c>
					</h>
					<r>
						<c>100</c>
						<c>+</c>
						<c>50</c>
					</r>
				</t>
				<p>If at least one of operators is a real number, the result will be a real number. If both operators are integers, the result will be an integer.</p>
				<p>The <b>addition</b> operator (<c>+</c>) adds numbers.</p>
				<c><![CDATA[
					var a = 2;
					var b = 3;
					var c = a + b; // 5]]>
				</c>
				<p>The <b>subtraction </b> operator (<c>-</c>) subtracts  numbers.</p>
				<c><![CDATA[
					var a = 2;
					var b = 3;
					var c = a - b; // -1]]>
				</c>
				<p>The <b>multiplication</b> operator (<c>*</c>) multiplies numbers.</p>
				<c><![CDATA[
					var a = 2;
					var b = 3;
					var c = a * b; // 6]]>
				</c>
				<p>The <b>division</b> operator (<c>/</c>) divides  numbers.</p>
				<c><![CDATA[
					var a = 6;
					var b = 2;
					var c = a / b; // 3]]>
				</c>
				<p>If at least one of operators is a real number, the Goat interpreter performs real division (for example, <c>6.0 / 4 = 1.5</c>). If both operators are integers, the interpreter performs integer division, i.e. the fractional part of the result will be lost (<c>6 / 4 = 1</c>).</p>
				<p>The <b>modular</b> operator (<c>%</c>) returns the division remainder.</p>
				<c><![CDATA[
					var a = 17;
					var b = 10;
					var c = a % b; // 7]]>
				</c>
				<p>The <b>increment </b> operator (<c>++</c>) increments numbers.</p>
				<c><![CDATA[
					var a = 2;
					a++; // 3]]>
				</c>
				<p>The <b>decrement</b> operator (<c>--</c>) decrements numbers.</p>
				<c><![CDATA[
					var a = 2;
					a--; // 1]]>
				</c>
			</s>
			<s name="Operator precedence">
				<p>Operator precedence describes the order in which operations are performed in an arithmetic expression.</p>
				<c>var x = 100 + 50 * 3;</c>
				<p>As in traditional mathematics, the multiplication is done first. Multiplication (<c>*</c>) and division (<c>/</c>) have higher <b>precedence</b> than addition (<c>+</c>) and subtraction (<c>-</c>).</p>
				<p>The precedence can be changed by using parentheses:</p>
				<c>var x = (100 + 50) * 3;</c>
				<p>When using parentheses, the operations inside the parentheses are computed first.</p>
				<p>When many operations have the same precedence (like addition and subtraction), they are computed from left to right:</p>
				<c>var x = 100 + 50 - 3;</c>
			</s>
			<s name="Operator precedence values">
				<t>
					<h>
						<c width="100">Value</c>
						<c width="100">Operator</c>
						<c>Description</c>
						<c>Example</c>
					</h>
					<r>
						<c>21</c>
						<c><c>()</c></c>
						<c>Expression grouping</c>
						<c><c>(3 + 4)</c></c>
					</r>
					<r>
						<c>20</c>
						<c><c>.</c></c>
						<c>Member</c>
						<c><c>person.name</c></c>
					</r>
					<r>
						<c>20</c>
						<c><c>[]</c></c>
						<c>Member</c>
						<c><c>person["name"]</c></c>
					</r>
					<r>
						<c>19</c>
						<c><c>()</c></c>
						<c>Function call</c>
						<c><c>func()</c></c>
					</r>
					<r>
						<c>19</c>
						<c><c>new</c></c>
						<c>Create</c>
						<c><c>new StringBuilder()</c></c>
					</r>
					<r>
						<c>18</c>
						<c><c>++</c></c>
						<c>Prefix increment</c>
						<c><c>++x</c></c>
					</r>
					<r>
						<c>18</c>
						<c><c>--</c></c>
						<c>Prefix decrement</c>
						<c><c>--x</c></c>
					</r>
					<r>
						<c>17</c>
						<c><c>++</c></c>
						<c>Postfix increment</c>
						<c><c>x++</c></c>
					</r>
					<r>
						<c>17</c>
						<c><c>--</c></c>
						<c>Postfix decrement</c>
						<c><c>x--</c></c>
					</r>
					<r>
						<c>16</c>
						<c><c>!</c></c>
						<c>Logical not</c>
						<c><c>!x</c></c>
					</r>
					<r>
						<c>15</c>
						<c><c>~</c></c>
						<c>Bitwise not</c>
						<c><c>~x</c></c>
					</r>
					<r>
						<c>14</c>
						<c><c>+</c></c>
						<c>Unary plus</c>
						<c><c>+x</c></c>
					</r>
					<r>
						<c>14</c>
						<c><c>-</c></c>
						<c>Unary minus</c>
						<c><c>-x</c></c>
					</r>
					<r>
						<c>13</c>
						<c><c>-&gt;</c></c>
						<c>Inherit</c>
						<c><c>A -&gt; { }</c></c>
					</r>
					<r>
						<c>12</c>
						<c><c>*</c></c>
						<c>Multiplication</c>
						<c><c>10 * 5</c></c>
					</r>
					<r>
						<c>12</c>
						<c><c>/</c></c>
						<c>Division</c>
						<c><c>10 / 5</c></c>
					</r>
					<r>
						<c>12</c>
						<c><c>%</c></c>
						<c>Modulo (remainder)</c>
						<c><c>17 % 10</c></c>
					</r>
					<r>
						<c>11</c>
						<c><c>+</c></c>
						<c>Addition</c>
						<c><c>2 + 3</c></c>
					</r>
					<r>
						<c>11</c>
						<c><c>-</c></c>
						<c>Subtraction</c>
						<c><c>5 - 2</c></c>
					</r>
					<r>
						<c>10</c>
						<c><c>&lt;&lt;</c></c>
						<c>Shift left</c>
						<c><c>x &lt;&lt; 2</c></c>
					</r>
					<r>
						<c>10</c>
						<c><c>&gt;&gt;</c></c>
						<c>Shift right</c>
						<c><c>x &gt;&gt; 2</c></c>
					</r>
					<r>
						<c>10</c>
						<c><c>&gt;&gt;&gt;</c></c>
						<c>Shift right (unsigned)</c>
						<c><c>x &gt;&gt;&gt; 2</c></c>
					</r>
					<r>
						<c>9</c>
						<c><c>&amp;</c></c>
						<c>Bitwise and</c>
						<c><c>x &amp; y</c></c>
					</r>
					<r>
						<c>8</c>
						<c><c>^</c></c>
						<c>Bitwise xor</c>
						<c><c>x ^ y</c></c>
					</r>
					<r>
						<c>7</c>
						<c><c>|</c></c>
						<c>Bitwise or</c>
						<c><c>x | y</c></c>
					</r>
					<r>
						<c>6</c>
						<c><c>&lt;</c></c>
						<c>Less than</c>
						<c><c>x &lt; y</c></c>
					</r>
					<r>
						<c>6</c>
						<c><c>&lt;=</c></c>
						<c>Less than or equal</c>
						<c><c>x &lt;= y</c></c>
					</r>
					<r>
						<c>6</c>
						<c><c>&gt;</c></c>
						<c>Greater than</c>
						<c><c>x &gt; y</c></c>
					</r>
					<r>
						<c>6</c>
						<c><c>&gt;</c></c>
						<c>Greater than or equal</c>
						<c><c>x &gt;= y</c></c>
					</r>
					<r>
						<c>5</c>
						<c><c>==</c></c>
						<c>Equal</c>
						<c><c>x == y</c></c>
					</r>
					<r>
						<c>5</c>
						<c><c>!=</c></c>
						<c>Not equal</c>
						<c><c>x != y</c></c>
					</r>
					<r>
						<c>4</c>
						<c><c>&amp;&amp;</c></c>
						<c>Logical and</c>
						<c><c>x &amp;&amp; y</c></c>
					</r>
					<r>
						<c>3</c>
						<c><c>||</c></c>
						<c>Logical or</c>
						<c><c>x || y</c></c>
					</r>
					<r>
						<c>2</c>
						<c><c>?</c></c>
						<c>Ternary operator</c>
						<c><c>a ? b : c</c></c>
					</r>
					<r>
						<c>1</c>
						<c><c>=</c></c>
						<c>Assign</c>
						<c><c>x = y</c></c>
					</r>
					<r>
						<c>1</c>
						<c><c>+=</c></c>
						<c>Assign by</c>
						<c><c>x += y</c></c>
					</r>
					<r>
						<c>1</c>
						<c><c>-=</c></c>
						<c>Assign by</c>
						<c><c>x -= y</c></c>
					</r>
					<r>
						<c>1</c>
						<c><c>*=</c></c>
						<c>Assign by</c>
						<c><c>x *= y</c></c>
					</r>
					<r>
						<c>1</c>
						<c><c>/=</c></c>
						<c>Assign by</c>
						<c><c>x *= y</c></c>
					</r>
					<r>
						<c>1</c>
						<c><c>%=</c></c>
						<c>Assign by</c>
						<c><c>x %= y</c></c>
					</r>
					<r>
						<c>1</c>
						<c><c>&lt;&lt;=</c></c>
						<c>Assign by</c>
						<c><c>x &lt;&lt;= y</c></c>
					</r>
					<r>
						<c>1</c>
						<c><c>&gt;&gt;=</c></c>
						<c>Assign by</c>
						<c><c>x &gt;&gt;= y</c></c>
					</r>
					<r>
						<c>1</c>
						<c><c>&gt;&gt;&gt;=</c></c>
						<c>Assign by</c>
						<c><c>x &gt;&gt;&gt;= y</c></c>
					</r>
					<r>
						<c>1</c>
						<c><c>&amp;=</c></c>
						<c>Assign by</c>
						<c><c>x &amp;= y</c></c>
					</r>
					<r>
						<c>1</c>
						<c><c>^=</c></c>
						<c>Assign by</c>
						<c><c>x ^= y</c></c>
					</r>
					<r>
						<c>1</c>
						<c><c>|=</c></c>
						<c>Assign by</c>
						<c><c>x |= y</c></c>
					</r>
				</t>
			</s>
		</s>
		<s name="Assignment">
			<p>The <c>=</c> assignment operator assigns a value to a variable.</p>
			<c>var x = 10; // 10</c>
			<p>The <c>+=</c> assignment operator adds a value to a variable.</p>
			<c><![CDATA[
				var x = 10;
				x += 5; // 15 ]]>
			</c>
			<p>The <c>-=</c> assignment operator subtracts a value from a variable.</p>
			<c><![CDATA[
				var x = 10;
				x -= 5; // 5 ]]>
			</c>
			<p>The <c>*=</c> assignment operator multiplies a variable.</p>
			<c><![CDATA[
				var x = 10;
				x *= 5; // 50 ]]>
			</c>
			<p>The <c>/=</c> assignment operator divides a variable.</p>
			<c><![CDATA[
				var x = 10;
				x /= 5; // 2 ]]>
			</c>
			<p>The <c>%=</c> assignment operator assigns a remainder to a variable.</p>
			<c><![CDATA[
				var x = 17;
				x %= 10; // 7 ]]>
			</c>
		</s>
		<s name="Data types">
			<p>Goat variables can hold many data types: numbers, strings, objects and more:</p>
			<c>	<![CDATA[
				var length = 16; // Integer
				var price = 11.99; // Real
				var name = "Ivan"; // String
				var obj = {name: "Ivan", age: 33}; // Object
				x %= 10; // 7 ]]>
			</c>
			<s name="Concept">
				<p>In programming, data types is an important concept. To be able to operate on variables, it is important to know something about the type.</p>
				<p>For example, when adding a number and a something, the Goat interpreter will treat the second operator as a number:</p>
				<c>var x = 2 + 3; // result is: 5</c>
				<p>But, when adding a string and a something, the Goat interpreter will treat the second operator as a string. If the second operator is not a string, the interpreter will convert it to the string:</p>
				<c>var s = "text" + 123; // result is: "text123"</c>
				<p>The Goat interpreter evaluates expressions from left to right (but according to precedence).  Different sequences can produce different results:</p>
				<c><![CDATA[
					var s1 = "text" + 2 + 3; // result is: "text23"
					var s2 = "text" + (2 + 3); // result is: "text5"]]>
				</c>
			</s>
			<s name="Goat types are dynamic">
				<p>The Goat language has dynamic types. This means that the same variable can be used to hold different data types:</p>
				<c><![CDATA[
					var x; // 'x' is undefined
					x = 5; // now 'x' is a integer
					x = "Ivan"; // now 'x' is a string]]>
				</c>
			</s>
			<s name="Strings">
				<p>A string (or a text string) is a series of characters like "Abracadabra". Strings are written with double quotes:</p>
				<c>var name="Ivan";</c>
			</s>
			<s name="Chars">
				<p>Char is a single symbol. Chars are written with single quotes:</p>
				<c>var c = 'A';</c>
			</s>
			<s name="Integers">
				<p>A number without decimal point:</p>
				<c>var i = 10;</c>
			</s>
			<s name="Real numbers">
				<p>A number with decimal point (also, it called "floating-point number"):</p>
				<c>var r = 0.01;</c>
			</s>
			<s name="Booleans">
				<p>Booleans can only have two values: <c>true</c> or <c>false</c>:</p>
				<c><![CDATA[
					var t = true;
					var f = false;]]>
				</c>
				<p>Booleans are often used in conditional testing:</p>
				<c><![CDATA[
					var x = 5;
					var y = 5;
					var z = 6;
					var t = (x == y); // true
					var f = (x == z); // false]]>
				</c>
			</s>
			<s name="Arrays">
				<p>Goat arrays are written with square brackets. Array items are separated by commas. The following code declares (creates) an array called <c>herd</c>, containing three items (goats nicknames):</p>
				<c>var herd = ["Dirty", "Stinky", "Crazy"];</c>
				<p>Array indexes are zero-based, which means the first item is <c>[0]</c>, second is <c>[1]</c>, and so on.</p>
			</s>
			<s name="Objects">
				<p>Goat objects are written with curly braces. Object properties are written as <c>name: value</c> pairs, separated by commas.</p>
				<c>var goat = { name: "Stinky", wool: Color.WHITE, age: 3}; </c>
			</s>
			<s name="Undefined">
				<p>In the Goat language, a variable without a value, has the value <c>undefined</c>.</p>
				<c>var name; // value is undefined</c>
				<p>Any variable can be emptied, by setting the value to <c>undefined</c>.</p>
				<c>name = undefined;</c>
			</s>
			<s name="Null">
				<p>In the Goat language, <c>null</c> is "nothing". It is supposed to be something that doesn't exist. Any variable can be emptied, by setting the value to <c>null</c>.</p>
				<c>name = null;</c>
			</s>
			<p><c>null</c> is not <c>undefined</c>! <c>null</c> means: it defined, but the value of it is "nothing".</p>
		</s>
		<s name="Functions">
			<p>A Goat function is a block of code designed to perform a particular task. A Goat function is executed when "something" invokes it (calls it).</p>
			<c><![CDATA[
				var myFunction = function(a, b) {
					return a * b; // the function returns the product of 'a' and 'b'
				};]]>
			</c>
			<p>Why Functions? You can reuse code: Define the code once, and use it many times. You can use the same code many times with different arguments, to produce different results.</p>
			<s name="Syntax">
				<p>A Goat function is defined with the <c>function</c> keyword, followed by parentheses (). The parentheses may include parameter names separated by commas: <c>(parameter_1, parameter_2, ...)</c>. The code to be executed, by the function, is placed inside curly brackets: <c>{}</c>. To name a function (for the ability of invocation), the function object needs to be written to a variable:</p>
				<c><![CDATA[
					var name = function(parameter_1, parameter_2, parameter_3) {
						//code to be executed
					};]]>
				</c>
				<p>In the Goat language, the <c>function</c> keyword (it is long and is used very often ) can be changed to a dollar sign <c>$</c>:</p>
				<c><![CDATA[
					var name = $(parameter_1, parameter_2, parameter_3) {
						//code to be executed
					};]]>
				</c>
				<p>Function <b>parameters</b> are listed inside the parentheses <c>()</c> in the function definition. Function <b>arguments</b> are the <b>values</b> received by the function when it is invoked. Inside the function, the arguments (the parameters) behave as local variables.</p>
			</s>
			<s name="Return">
				<p>When the Goat interpreter reaches a <b>return statement</b>, the function will stop executing, then the interpreter will "return" to execute the code after the invoking statement. Functions often compute a return value. The return value is "returned" back to the "caller":</p>
				<c><![CDATA[
					var myFunction = function(a, b) {
						return a * b; // the function returns the product of 'a' and 'b'
					};
					
					var x = myFunction(4, 3);]]>
				</c>
				<p>The result in <c>x</c> will be <c>12</c>.</p>
			</s>
			<s name="Invocation">
				<p>The <c>()</c> operator invokes the function.</p>.
				<p>To invoke a function without arguments, use empty operator:</p>
				<c><![CDATA[
					var doSomething = function() {
						//...
					};
					
					//...
					
					doSomething();]]>
				</c>
				<p>To invoke a function with arguments, place arguments, separated by comma, inside the <c>()</c> operator: </p>
				<c><![CDATA[
					var doSomething = function(a, b, c) {
						//...
					};
					
					//...
					
					doSomething("test", 3.14, false);]]>
				</c>
				<p>An argument can be any expression - string, number, another function call etc.</p>
			</s>
			<s name="Built-in functions">
				<p>The Goat language has a lot of built-in functions (so-called built-in library). This library provides type definitions and functions for tasks such as string handling, mathematical computations, input/output processing and several other operating system services.</p>
				<p>For example, the <c>print</c> function converts the first argument to a string and outputs it to a console:</p>
				<c>print(2 + 3); // outputs: 5</c>
				<p><d>Built-in functions are fully described in the appropriate chapter.</d></p>
			</s>
		</s>
		<s name="Objects">
			<s name="Real life objects, properties and methods">
				<p>In real life, a car is an <b>object</b>. A car has <b>properties</b> like weight and color, and <b>methods</b> like start and stop.</p>
				<p>Object:</p>
				<c>var car = {};</c>
				<p>Properties:</p>
				<c><![CDATA[
					car.name = "Fiat";
					car.model = 500;
					car.weight = "850kg";
					car.color = "white";]]>
				</c>
				<p>Methods:</p>
				<c><![CDATA[
					car.start();
					car.drive();
					car.brake();
					car.stop();]]>
				</c>
				<p>All cars have the same <b>properties</b>, but the property values differ from car to car.</p>
				<p>All cars have the same <b>methods</b>, but the methods are performed at different times.</p>
			</s>
			<s name="Goat objects">
				<p>Recall that Goat variables are containers for data values. This code assigns a simple value ("Fiat") to a variable named <c>car</c>:</p>
				<c>var car = "Fiat";</c>
				<p>Objects are variables too. But objects can contain many values. This code assigns <b>many values</b> ("Fiat", 500, "white") to a <b>variable</b> named car:</p>
				<c>var car = {type: "Fiat", model: 500, color:"white"};</c>
				<p>The values are written as <c>name:value</c> pairs (name and value separated by a colon).</p>
			</s>
			<s name="Properties">
				<p>The <c>name:values</c> pairs (in Goat objects) are called properties.</p>
				<c>var goat = { name: "Stinky", wool: Color.WHITE, age: 3 };</c>
				<t>
					<h>
						<c width="100">Property</c>
						<c>Value</c>
					</h>
					<r>
						<c>name</c>
						<c>"Stinky"</c>
					</r>
					<r>
						<c>wool</c>
						<c>Color.WHITE</c>
					</r>
					<r>
						<c>age</c>
						<c>3</c>
					</r>
				</t>
			</s>
			<s name="Methods">
				<p>Methods are <b>actions</b> that can be performed on objects. Methods are stored in properties as <b>function definitions.</b> In other words, methods are functions that are performed on an object.</p>
				<c><![CDATA[
					var person = {
						firstName : "Scott",
						lastName : "Cameron",
						age : 45,
						
						fullName : function() {
							return firstName + ' ' + lastName;
						}
					};
					
					var name = person.fullName(); // result is: "Scott Cameron"]]>
				</c>
			</s>
			<s name="Definition">
				<p>You define (and create) a Goat object with an object literal:</p>
				<c>var person = { firstName : "Scott", lastName : "Cameron", age : 45 };</c>
				<p>Spaces and line breaks are not important. An object definition can span multiple lines:</p>
				<c><![CDATA[
					var person = {
						firstName : "Scott",
						lastName : "Cameron",
						age : 45
					};]]>
				</c>
			</s>
			<s name="Accessing object properties">
				<p>You can access object properties in two ways:</p>
				<c>objectName.propertyName</c>
				<p>or</p>
				<c>objectName["propertyName"]</c>
				<p>For example,</p>
				<c>person.lastName</c>
				<p>or</p>
				<c>person["lastName"];</c>
			</s>
			<s name="Accessing object methods">
				<p>You access an object method with the following syntax:</p>
				<c>objectName.methodName()</c>
				<p>For example,</p>
				<c>name = person.fullName();</c>
			</s>
			<s name="Nested objects">
				<p>Properties can be not only strings and numbers, but also arrays and objects:</p>
				<c><![CDATA[
					var person = {
						firstName : "Scott",
						lastName : "Cameron",
						age : 45,
						children: [
							{ firstName: "Ann", lastName: "Cameron", age: 10 },
							{ firstName: "Dave", lastName: "Cameron", age: 14 }
						]
					};]]>
				</c>
				<p>Thus, objects can be unlimitedly nested within each other.</p>
			</s>
			<s name="Objects, variables and references">
				<p>Let's create a new object and assign it to a variable:</p>
				<c>var a = { name: "Ivan", age: 33 };</c>
				<p>Then, let's assign this variable to another variable:</p>
				<c>var b = a;</c>
				<p>Okay. Now, we try to look what the second variable contains:</p>
				<c>print(b); // output: {name:"Ivan",age:33}</c>
				<p>Right, it contains the same that contains the first variable. Now, we change one property of the second variable:</p>
				<c>b.name = "John";</c>
				<p>Now let's look at the result:</p>
				<c>print(b); // output: {name:"John",age:33}</c>
				<p>And now let's see what the first variable contains:</p>
				<c>print(a); // output: {name:"John",age:33}</c>
				<p>Thus, we changed the property of the second variable, but the first one also changed. Why? The Goat programming language does not store whole objects in variables. <b>The Goat programming language stores in the variables only references to objects, but not the objects themselves.</b> If you copy one variable to another, only the reference is copied.</p>
				<p>What can you do if you need to make a real copy of the object? Use special method <c>clone</c>:</p>	
				<c><![CDATA[
					var a = { name: "Ivan", age: 33 };
					var b = a.clone();
					b.name = "Jonh";
					print(b); // output: {name:"John",age:33}
					print(a); // output: {name:"Ivan",age:33}]]>
				</c>
			</s>
		</s>
		<s name="Scope">
			<p>Scope determines the accessibility (visibility) of variables.</p>
			<p>Variables declared within a Goat block (function, etc), become <b>local</b> to this block. Local variables have local scope: they can only be accessed within the block.</p>
			<c><![CDATA[
				// code here can not use 'nickname'
				
				var myFunction = function() {
					var nickname = "Stinky";
					
					// code here can use 'nickname'
				};
				
				// code here can not use 'nickname']]>
			</c>
			<p>However, local variables can be accessed from inner blocks:</p>
			<c><![CDATA[
				var myFunction = function() {
					var nickname = "Stinky";
					
					//...
					if (expression) {
						// code here can use 'nickname'
					}
					
					// code here can use 'nickname'
				};]]>
			</c>
			<p>Functions are inner blocks also. So, each function can access variables, declared outside this function:</p>
			<c><![CDATA[
				var myFunction = function() {
					var nickname = "Stinky";
					
					//...
					var innerFunction = function() {
						// code here can use 'nickname'
					};
					
					// code here can use 'nickname'
				};]]>
			</c>
			<p>Variables declared within a block, redefines variables with the same names, declared outside a block. New variable uses only in this block:</p>
			<c><![CDATA[
				var myFunction = function() {
					var nickname = "Stinky";
					//...
					print(nickname); // output: "Stinky"
					//...
					var innerFunction = function() {
						var nickname = "Dirty"; // redefine 'nickname' variable
						//...
						print(nickname); // output: "Dirty"
					};
					//...
					innerFunction();
					//...
					print(nickname); // output: "Stinky"
				};]]>
			</c>
		</s>
		<s name="Strings">
			<p>Goat strings are used for storing and manipulating text.</p>
			<s name="Definition">
				<p>A Goat string is zero or more characters written inside double quotes.</p>
				<c>var s = "Have a nice day";</c>
			</s>
			<s name="Special characters">
				<p>Because strings must be written within quotes, Goat will misunderstand this string:</p>
				<c>var s = "The line "No, I am your father" is often misquoted as "Luke, I am your father."";</c>
				<p>The string will be chopped to <c>"The line "</c>.</p>
				<p>The solution to avoid this problem, is to use the <b>backslash escape character.</b> The backslash (<c>\</c>) escape character turns special characters into string characters:</p>
				<t>
					<h>
						<c width="120">Code</c>
						<c width="120">Result</c>
						<c>Description</c>
					</h>
					<r>
						<c><c>\n</c></c>
						<c></c>
						<c>New line</c>
					</r>
					<r>
						<c><c>\r</c></c>
						<c></c>
						<c>Carriage return</c>
					</r>
					<r>
						<c><c>\t</c></c>
						<c></c>
						<c>Tabulation</c>
					</r>
					<r>
						<c><c>\"</c></c>
						<c><c>"</c></c>
						<c>Double quote</c>
					</r>
					<r>
						<c><c>\\</c></c>
						<c><c>\</c></c>
						<c>Backslash</c>
					</r>
				</t>
				<p>The sequence <c>\"</c> inserts a double quote in a string:</p>
				<c>var s = "The line \"No, I am your father\" is often misquoted as \"Luke, I am your father.\"";</c>
				<p>The sequence <c>\\</c> inserts a backslash in a string:</p>
				<c>var s = "The character \\ is called backslash.";</c>
			</s>
			<s name="Strings are objects">
				<p>The Goat language has no primitive types. All data represented as objects, including strings. For example, 
				another way to define string is the explicit definition (as an object) by operator <c>new</c>:</p>
				<c>var s = new String("My name is Ivan");</c>
				<p>Don't create strings using operator new. This makes no sense. This example is needed to show that in principle, the string does not differ from other objects (it has a prototype, it can be created by the <c>new</c> operator, and so on).</p>
				<p>Since a string is an object, it has properties, including methods. For example, the <c>length</c> method returns the length of a string:</p>
				<c><![CDATA[
					var s = "Test";
					var n = s.length(); // value of 'n' will be 4]]>
				</c>
			</s>
			<s name="String methods">
				<m name="length" descr="Returns the length of a string."/>
				<m name="subString" descr="Extracts a part of a string and returns the extracted part in a new string.">
					<a name="start" type="Integer" descr="the starting index (position). 0 is the first symbol"/>
					<a name="count" type="Integer" descr="optional; count of characters. If not specified, the substring begins with the character at the specified index and extends to the end of this string. If specified, anyway, the method returns not more symbols than it possible"/>
					<e><![CDATA[
						var a = "This is an example.";
						var b = a.subString(5, 2); // "is"
						var c = a.subString(11); // "example."]]>
					</e>
				</m>
				<m name="split" descr="Splits a string into an array of substrings using a separator.">
					<a name="separator" type="Char" descr="a separator"/>
					<e><![CDATA[
						var s = "My name is James Bond";
						var a = s.split(' '); // ["My","name","is","James","Bond"] ]]>
					</e>
				</m>
				<m name="valueOf" descr="Converts any object to a string.">
					<a name="object" type="any type" descr="an object"/>
					<e><![CDATA[
						var i = 256 * 256;
						var s = String.valueOf(i); // "65536" ]]>
					</e>
					<n>This is the static method, i.e. meant to be relevant to all the instances of a class rather than to any specific instance.</n>
				</m>
			</s>
			<s name="String operators">
				<p>Remind that each object (include strings) supports these operators: <c>-&gt;</c> (inherit), <c>==</c> (equal), <c>!=</c> (not equal) and <c>!</c> (logical not). Other operators are:</p>
				<h name="+, +=">
					<p>Converts the second operand to a string and then concatenates strings.</p>
					<c><![CDATA[
						var s0 = "hello" + ", " + "world!"; // "hello, world!";
						var s1 = "test" + 123; // "test123"
						var s2 = "value";
						s2 += 3.14; // "value3.14" ]]>
					</c>
					<p>One of the simplest methods to convert anything to a string is adding this object to an empty string:</p>
					<c>var s = "" + 3.14; // "3.14"</c>
				</h>
				<h name="&lt;, &lt;=, &gt;, &gt;=">
					<p>Lexicographical comparison of strings. If the second operator is not a string, returns <c>false</c>.</p>
					<c>print("hello" &gt;= "hell"); // outputs: true</c>
				</h>
			</s>
		</s>
		<s name="Characters">
			<p>A character (<c>Char</c>) is a type that corresponds to a symbol or grapheme: letter, digit etc.</p>
			<s name="Definition">
				<p>A Goat char is one character written inside single quotes.</p>
				<c>var c = 'A';</c>
			</s>
			<s name="Special characters">
				<p>As in strings, special characters after a backslash can be used here:</p>
				<t>
					<h>
						<c width="120">Code</c>
						<c width="120">Result</c>
						<c>Description</c>
					</h>
					<r>
						<c><c>\n</c></c>
						<c></c>
						<c>New line</c>
					</r>
					<r>
						<c><c>\r</c></c>
						<c></c>
						<c>Carriage return</c>
					</r>
					<r>
						<c><c>\t</c></c>
						<c></c>
						<c>Tabulation</c>
					</r>
					<r>
						<c><c>\'</c></c>
						<c><c>'</c></c>
						<c>Single quote</c>
					</r>
					<r>
						<c><c>\\</c></c>
						<c><c>\</c></c>
						<c>Backslash</c>
					</r>
				</t>
				<p>The sequence <c>\'</c> means a single quote:</p>
				<c>var c = '\'';</c>
			</s>
			<s name="Char methods">
				<m name="valueOf" descr="Static method. Converts object to a char.">
					<a name="object" type="any type" descr="an object"/>
					<e><![CDATA[
						var i = 65;
						var c = Char.valueOf(i); // 'A' ]]>
					</e>
					<n>If the object is an integer, returns a Char containing the character associated with the specified character code. Else, if the object is a char, just returns this object. Else, if the object is not an integer and is not a char, returns '\0' (char with zero value).</n>
				</m>
			</s>
			<s name="Char operators">
				<h name="++, --">
					<p>Increments or decrements of a <c>Char</c> variable (or a field) by 1.</p>
					<c><![CDATA[
						var c = 'A'; // 'A';
						c++; // 'B'
						c++; // 'C'
						c--; // 'B' ]]>
					</c>
				</h>
				<h name="&lt;, &lt;=, &gt;, &gt;=">
					<p>Comparison of two <c>Char</c> objects. If the second parameter is not a char, throws an <c>IllegalArgument</c> exception.</p>
					<c>print('A' &gt; 'B'); // outputs: false</c>
					<p>What is an "exception" is described in the appropriate section.</p>
				</h>
			</s>
		</s>
		<s name="Numbers">
			<p>The Goat interpreter operates two type of numbers: integers and real numbers.</p>
			<s name="Integers">
				<s name="Definition">
					<p>Integer numbers are written without decimal point:</p>
					<c>var i = 3;</c>
					<p>Also, Goat interprets numerical constants as hexadecimal if they are preceded by <c>0x</c>:</p>
					<c>var i = 0xFF;</c>
					<p>and interprets numerical constants as binary if they are preceded by <c>0b</c>:</p>
					<c>var i = 0b1011;</c>
				</s>
				<s name="Methods">
					<m name="toString" descr="Converts an integer to a string.">
						<a name="radix" type="Integer" descr="optional, radix, can be 2, 10 or 16"/>
						<e><![CDATA[
							var i = 254;
							var s = i.toString(); // "254"
							var h = "0x" + i.toString(16); // "0xFE"]]>
						</e>
					</m>
				</s>
				<s name="Operators">
					<p>The Integer type has more operators than the other types.</p>
					<h name="+, +=, -, -=, *, *=, /, /=">
						<p>Addition, subtraction, multiplication and division. Note that multiplication and division have a higher precedence than addition and subtraction, just as in algebra. If the second operand is a real number, then the result will also be a real number. If the second operand is an integer, the result will integer. Else if the second operand is not a number,  throws an <c>IllegalArgument</c> exception.</p>
						<c><![CDATA[
							var a = 2;
							var b = 3;
							var c = 5;
							var x = a + b * c; // 17 ]]>
						</c>
					</h>
					<h name="%, %=">
						<p>Modulo (remainder). Returns the remainder of an integer divided by an integer.</p>
						<c>var x = 17 % 10 // 7</c>
					</h>
					<h name="&lt;, &lt;=, &gt;, &gt;=">
						<p>Comparison of two numbers (integer or real number). If the second parameter is not a number, throws an <c>IllegalArgument</c> exception.</p>
						<c>print(4 &gt; 3); // outputs: false</c>
					</h>
					<h name="++, --">
						<p>Increments or decrements of an <c>Integer</c> variable (or a field) by 1.</p>
						<c><![CDATA[
							var x = 1; // 1;
							x++; // 2
							x++; // 3
							x--; // 2 ]]>
						</c>
					</h>
					<h name="~">
						<p>The bitwise <b>not</b>, or complement, is a unary operation that performs logical negation on each bit, forming the ones' complement of the given binary value. Bits that are 0 become 1, and those that are 1 become 0:</p>
						<c><![CDATA[
							var x = 0b1011;
							var n = ~x; // ...1110100 ]]>
						</c>
						<p>The integer consists of a large number of bits (<d>depending on the implementation, usually 64</d>), all these bits change their values. So in this example, all first bits became 1.</p>
					</h>
					<h name="&lt;&lt;, &lt;&lt;=">
						<p>Left shift, i.e.  bitwise operation that shifts all the bits of its operand. Shifts left by pushing zeros in from the right and let the leftmost bits fall off.</p>
						<c><![CDATA[
							var x = 0b1011;
							var s = x << 2; // 101100 ]]>
						</c>
						<p>Left shifts can be useful as an efficient way to perform multiplication of unsigned integers by powers of 2. Shifting left by <c>n</c> bits on unsigned binary number has the effect of multiplying it by 2 to the power of <c>n</c>:</p>
						<c><![CDATA[
							var x = 5;
							var s = x << 3; // 5 * 8 = 40 ]]>
						</c>
					</h>
					<h name="&gt;&gt;, &gt;&gt;=">
						<p>Signed right shift, shifts right by pushing copies of the leftmost bit in from the left, and let the rightmost bits fall off.</p>
						<c><![CDATA[
							var x = -5 // ...111011;
							var s = x > 1; // ...111101 (-3) ]]>
						</c>
					</h>
					<h name="&gt;&gt;&gt;, &gt;&gt;&gt;=">
						<p>Unsigned (zero fill) right shift, one or more zero bits are pushed in from the left, and the rightmost bits fall off.</p>
						<c><![CDATA[
							var x = 5 // 101;
							var s = x >>> 1; // 010 (2) ]]>
						</c>
					</h>
					<h name="&amp;, &amp;=">
						<p>Bitwise <b>and</b> returns 1 only if both bits are 1.</p>
						<c><![CDATA[
							var x = 5 // 101;
							var y = 1 // 001;
							var b = x & y; // 001 (1) ]]>
						</c>
					</h>
					<h name="|, |=">
						<p>Bitwise <b>or</b> returns 1 if one of the bits are 1.</p>
						<c><![CDATA[
							var x = 5 // 101;
							var y = 1 // 001;
							var b = x | y; // 101 (5) ]]>
						</c>
					</h>
					<h name="^, ^=">
						<p>Bitwise <b>xor</b> returns 1 if the bits are different.</p>
						<c><![CDATA[
							var x = 5 // 101;
							var y = 1 // 001;
							var b = x ^ y; // 100 (4) ]]>
						</c>
					</h>
				</s>
			</s>
			<s name="Real numbers">
				<s name="Definition">
					<p>Real numbers are written with the decimal point (dot):</p>
					<c>var i = 3.14;</c>
				</s>
				<s name="Operators">
					<p>Real type supports only these operators: <c>+</c>, <c>+=</c>, <c>-</c>, <c>-=</c>, <c>*</c>, <c>*=</c>, <c>/</c>, <c>/=</c>, <c>&lt;</c>, <c>&lt;=</c>, <c>&gt;</c>, <c>&gt;=</c>, <c>++</c>, <c>--</c>. Bitwise operators are not supported.</p>
				</s>
			</s>
		</s>
		<s name="Arrays">
			<p>Goat arrays are used to store multiple values in a single variable.</p>
			<s name="Creating an array">
				<p>Using an array literal <c>[ ]</c>:</p>
				<c>var array_name = [item1, item2, ...];</c>
				<p>For example:</p>
				<c>var herd = ["Dirty", "Stinky", "Crazy"];</c>
				<p>Spaces and line breaks are not important. A declaration can span multiple lines:</p>
				<c><![CDATA[
					var herd = [
						"Dirty",
						"Stinky",
						"Crazy"
					];]]>
				</c>
				<p>Array elements can be objects, arrays, numbers, strings... (remind that numbers, strings etc - all are objects). Arrays are special kinds of objects. You can have functions in an array. You can have even arrays in an array.</p> 
			</s>
			<s name="Access the elements of an array">
				<p>You refer to an array element by referring to the <b>index number.</b> <c>[0]</c> is the first element in an array. <c>[1]</c> is the second. Array indexes start with 0.</p>
				<p>This statement accesses the value of the first element in <c>herd</c> array:</p>
				<c>var name = herd[0];</c>
				<p>This statement modifies the first element in <c>herd</c> array:</p>
				<c>herd[0] = "Nasty";</c>
			</s>
			<s name="Adding array elements">
				<p>The way to add a new element to an array is using the <c>push</c> method:</p>
				<c><![CDATA[
					var fruits = ["Banana", "Orange", "Apple", "Mango"];
					fruits.push("Lemon"); // adds a new element ("Lemon") to fruits ]]>
				</c>
			</s>
			<s name="The difference between arrays and objects">
				<p>Arrays use <b>numbered indexes.</b></p>
				<p>Objects use <b>named indexes.</b></p>
				<p>Arrays are a special kind of objects, with numbered indexes.</p>
			</s>
			<s name="Array methods">
				<m name="length" descr="Returns the length (count of items) of an array."/>
				<m name="push" descr="Adds a new item to the end of an array.">
					<a name="object" type="any type" descr="an item"/>
				</m>
			</s>
			<s name="Looping array elements">
				<p>The best way to loop through an array, is using a <c>for</c> loop:</p>
				<c><![CDATA[
					var fruits = ["Banana", "Orange", "Apple", "Mango"];
					var i, l = fruits.length();
					for (i = 0; i < l; i++) {
						print(fruits[i] + "\n");
					}]]>
				</c>
			</s>
		</s>
		<s name="Booleans">
			<p>A Goat <c>Boolean</c> represents one of two values: <c>true</c> or <c>false</c>.</p>
			<s name="Boolean values">
				<p>Very often, in programming, you will need a data type that can only have one of two values, like</p>
				<l>
					<i><b>Yes</b> or <b>No</b></i>
					<i><b>On</b> or <b>Off</b></i>
					<i><b>True</b> or <b>False</b></i>
				</l>
				<p>For this, The Goat programming language has a <c>Boolean</c> data type. It can only take the values <c>true</c> or <c>false</c>.</p>
				<c><![CDATA[
					var t = true;
					var f = false; ]]>
				</c>
			</s>
			<s name="Comparisons and conditions">
				<p>The chapter "Comparisons" gives a full overview of comparison operators.</p>
				<p>The chapter "Conditions" gives a full overview of conditional statements.</p>
				<p>Here are some examples:</p>
				<t>
					<h>
						<c width="100">Operator</c>
						<c>Description</c>
						<c>Example</c>
					</h>
					<r>
						<c><c>==</c></c>
						<c>Equal to</c>
						<c><c>if (day == "Monday")</c></c>
					</r>
					<r>
						<c><c>&gt;</c></c>
						<c>Greater than</c>
						<c><c>if (salary &gt; 9000)</c></c>
					</r>
					<r>
						<c><c>&lt;</c></c>
						<c>Less than</c>
						<c><c>if (age &lt; 18)</c></c>
					</r>
				</t>
				<p>The Boolean value of an expression is the basis for all Goat comparisons and conditions.</p>
			</s>
		</s>
		<s name="Comparison and logical operators">
			<p>Comparison and logical operators are used to test for <c>true</c> or <c>false</c>.</p>
			<s name="Comparison operators">
				<p>Comparison operators are used in logical statements to determine equality or difference between variables or values.</p>
				<p>Given that <c>x = 5</c>, the table below explains the comparison operators:</p>
				<t>
					<h>
						<c width="100">Operator</c>
						<c>Description</c>
						<c>Comparing</c>
						<c>Returns</c>
					</h>
					<r>
						<c><c>==</c></c>
						<c>Equal to</c>
						<c><c>x == 8</c></c>
						<c><c>false</c></c>
					</r>
					<r>
						<c/>
						<c/>
						<c><c>x == 5</c></c>
						<c><c>true</c></c>
					</r>
					<r>
						<c/>
						<c/>
						<c><c>x == "5"</c></c>
						<c><c>false</c></c>
					</r>
					<r>
						<c><c>!=</c></c>
						<c>Not equal</c>
						<c><c>x != 8</c></c>
						<c><c>true</c></c>
					</r>
					<r>
						<c><c>&gt;</c></c>
						<c>Greater than</c>
						<c><c>x &gt; 8</c></c>
						<c><c>false</c></c>
					</r>
					<r>
						<c><c>&lt;</c></c>
						<c>Less than</c>
						<c><c>x &lt; 8</c></c>
						<c><c>true</c></c>
					</r>
					<r>
						<c><c>&gt;=</c></c>
						<c>Greater than or equal to</c>
						<c><c>x &gt;= 8</c></c>
						<c><c>false</c></c>
					</r>
					<r>
						<c><c>&lt;=</c></c>
						<c>Less than or equal to</c>
						<c><c>x &lt;= 5</c></c>
						<c><c>true</c></c>
					</r>
				</t>
				<p>Comparison operators can be used in conditional statements to compare values and take action depending on the result:</p>
				<c>if (age &lt; 18) print("Too young");</c>
			</s>
			<s name="Logical operators">
				<p>Logical operators are used to determine the logic between variables or values.</p>
				<p>Given that <c>x = 6</c> and <c>y = 3</c>, the table below explains the logical operators:</p>
				<t>
					<h>
						<c width="100">Operator</c>
						<c>Description</c>
						<c>Example</c>
						<c>Returns</c>
					</h>
					<r>
						<c><c>&amp;&amp;</c></c>
						<c>Logical <b>and</b></c>
						<c><c>(x &lt; 10 &amp;&amp; y &gt; 1)</c></c>
						<c><c>true</c></c>
					</r>
					<r>
						<c><c>||</c></c>
						<c>Logical <b>or</b></c>
						<c><c>(x == 5 || y == 5)</c></c>
						<c><c>false</c></c>
					</r>
					<r>
						<c><c>!</c></c>
						<c>Logical <b>not</b></c>
						<c><c>!(x == y)</c></c>
						<c><c>true</c></c>
					</r>
				</t>
				<h name="Logical and (&amp;&amp;)">
					<p>The expression <c>A &amp;&amp; B</c> is <c>true</c> if <c>A</c> and <c>B</c> are both <c>true</c>; else it is <c>false</c>.</p>
				</h>
				<h name="Logical or (||)">
					<p>The expression <c>A || B</c> is <c>true</c> if <c>A</c> or <c>B</c> (or both) are <c>true</c>; if both are <c>false</c>, the expression is <c>false</c>.</p>
				</h>
				<h name="Logical not (!)">
					<p>The expression <c>!A</c> is <c>true</c> if <c>A</c> is <c>false</c>.</p>
				</h>
			</s>
			<s name="Conditional (ternary) operator">
				<p>Goat also contains a conditional operator that assigns a value to a variable based on some condition:</p>
				<c>variablename = (condition) ? value1 : value2</c>
				<p>For example,</p>
				<c>var voteable = (age &lt; 18) ? "Too young" : "Old enough";</c>
				<p>If the variable <c>age</c> is a value below 18, the value of the variable voteable will be <c>"Too young"</c>, otherwise the value of voteable will be <c>"Old enough"</c>.</p>
			</s>
			<s name="Comparing different types">
				<p>Comparing data of different types may give unexpected results. As a rule, the operators <c>==</c> and <c>!=</c> check that the types of the two variables match, otherwise will be returned false. For example, you can compare numbers but you can not compare a number and a string. If you need to compare, just explicit convert an operand to another type to match the second operand:</p>
				<c><![CDATA[
					var s = "1024";
					var i = 256 * 4;
					if (String.valueOf(i) == s) {
						// do something
					}]]>
				</c>
				<p>There is one exclusion. You can compare integer numbers and real numbers although they are different types. An integer operand will be converted to a real before comparison.</p>
			</s>
		</s>
		<s name="Conditions">
			<s name="Conditional statements">
				<p>Conditional statements are used to perform different actions based on different conditions.</p>
				<p>Very often when you write code, you want to perform different actions for different decisions. You can use conditional statements in your code to do this. In Goat we have the following conditional statements:</p>
				<l>
					<i>Use <c>if</c> to specify a block of code to be executed, if a specified condition is true</i>
					<i>Use <c>else</c> to specify a block of code to be executed, if the same condition is false</i>
					<i>Use <c>else if</c> to specify a new condition to test, if the first condition is false</i>
					<i>Use <c>switch</c> to specify many alternative blocks of code to be executed</i>
				</l>
			</s>
			<s name="The 'if' statement">
				<p>Use the <c>if</c> statement to specify a block of Goat code to be executed if a condition is true. Syntax:</p>
				<c><![CDATA[
					if (condition) {
						block of code to be executed if the condition is true
					}]]>
				</c>
				<p>Example (outputs <c>"Good day"</c>):</p>
				<c><![CDATA[
					var hour = 12;
					//...
					if (hour < 18) {
						print("Good day");
					}]]>
				</c>
				<p>Note that <c>if</c> is in lowercase letters. Uppercase letters (<c>If</c> or <c>IF</c>) will generate a Goat error.</p>
			</s>
			<s name="The 'else' statement">
				<p>Use the <c>else</c> statement to specify a block of code to be executed if the condition is false. Syntax:</p>
				<c><![CDATA[
					if (condition) {
						block of code to be executed if the condition is true
					}
					else {
						block of code to be executed if the condition is false
					}]]>
				</c>
				<p>Example (outputs <c>"Good evening"</c>):</p>
				<c><![CDATA[
					var hour = 12;
					//...
					if (hour < 18) {
						print("Good day");
					}
					else {
						print("Good evening");
					}]]>
				</c>
			</s>
			<s name="The 'else if' statement">
				<p>Use the <c>else if</c> statement to specify a new condition if the first condition is false. Syntax:</p>
				<c><![CDATA[
					if (condition1) {
						block of code to be executed if condition1 is true
					}
					else if (condition2) {
						block of code to be executed if the condition1 is false and condition2 is true
					}
					else {
						block of code to be executed if the condition1 is false and condition2 is false
					}]]>
				</c>
				<p>Example:</p>
				<c><![CDATA[
					if (hour < 10) {
						print("Good morning");
					}
					else if (hour < 18) {
						print("Good day");
					}
					else {
						print("Good evening");
					}]]>
				</c>
			</s>
		</s>
		<s name="Switch statement">
			<p>The switch statement is used to perform different actions based on different conditions. Use the switch statement to select one of many blocks of code to be executed.</p>
			<s name="Syntax">
				<c><![CDATA[
					switch(expression) {
						case n:
							code block
							break;
						case n:
							code block
							break;
						default:
							code block
					}]]>
				</c>
				<p>This is how it works:</p>
				<l>
					<i>The switch expression is evaluated once.</i>
					<i>The value of the expression is compared with the values of each case.</i>
					<i>If there is a match, the associated block of code is executed.</i>
				</l>
				<p>Example. This function converts weekday (as a number between 0 and 6) to a string:</p>
				<c><![CDATA[
					var weekday = function(number) {
						var day;
						switch (number) {
							case 0:
								day = "Sunday";
								break;
							case 1:
								day = "Monday";
								break;
							case 2:
								day = "Tuesday";
								break;
							case 3:
								day = "Wednesday";
								break;
							case 4:
								day = "Thursday";
								break;
							case 5:
								day = "Friday";
								break;
							case 6:
								day = "Saturday";
						}
						return day;
					}; ]]>
				</c>
			</s>
			<s name="The 'break' keyword">
				<p>When Goat reaches a <c>break</c> keyword, it breaks out of the switch block. This will stop the execution of more code and case testing inside the block. When a match is found, and the job is done, it's time for a break. There is no need for more testing.</p>
				<p>It is not necessary to break the last case in a switch block. The block breaks (ends) there anyway.</p>
			</s>
			<s name="The 'default' keyword">
				<p>The <c>default</c> keyword specifies the code to run if there is no case match.</p>
				<p>Example. This function converts weekday (as a number between 0 and 6) to a string, but if weekday is neither Saturday (6) nor Sunday (0), returns a default message:</p>
				<c><![CDATA[
					var weekday = function(number) {
						var day;
						switch (number) {
							case 0:
								day = "Sunday";
								break;
							case 6:
								day = "Saturday";
								break;
							default:
								day = "Working day";
						}
						return day;
					}; ]]>
				</c>
				<p>The default case (if exists) should be the last case in a switch block.</p>
			</s>
			<s name="Common code blocks">
				<p>Sometimes you will want different switch cases to use the same code:</p>
				<c><![CDATA[
					var weekday = function(number) {
						var day;
						switch (number) {
							case 0:
								day = "Sunday";
								break;
							case 6:
								day = "Saturday";
								break;
							case 4:
							case 5:
								day = "Soon it is Weekend";
								break;
							default:
								day = "Working day";
						}
						return day;
					}; ]]>
				</c>
			</s>
		</s>
		<s name="Loops">
			<s name="What is loops">
				<p>Loops can execute a block of code a number of times.</p>
				<p>Loops are handy, if you want to run the same code over and over again, each time with a different value. Often this is the case when working with arrays.</p>
				<p>For example, we have an array:</p>
				<c>var herd = ["Dirty", "Stinky", "Crazy", "Nasty", "Dumb", "Dumber"];</c>
				<p>Instead of writing:</p>
				<c><![CDATA[
					print(herd[0] + "\n");
					print(herd[1] + "\n");
					print(herd[2] + "\n");
					print(herd[3] + "\n");
					print(herd[4] + "\n");
					print(herd[5] + "\n");]]>
				</c>
				<p>You can write:</p>
				<c><![CDATA[
					var i, l = herd.length();
					for (i = 0; i < l; i++) {
						print(herd[i] + "\n");
					}]]>
				</c>
			</s>
			<s name="Different kinds of loops">
				<p>Goat supports different kinds of loops:</p>
				<l>
					<i><c>for</c> - loops through a block of code a number of times;</i>
					<i><c>for..in</c> - loops through the properties of an object;</i>
					<i><c>while</c> - loops through a block of code while a specified condition is true;</i>
					<i><c>do..while</c> - also loops through a block of code while a specified condition is true.</i>
				</l>
			</s>
			<s name="The 'for' loop">
				<p>The <c>for</c> loop is often the tool you will use when you want to create a loop. The <c>for</c> loop has the following syntax:</p>
				<c><![CDATA[
					for (statement 1; statement 2; statement 3) {
						code block to be executed
					}]]>
				</c>
				<p><b>Statement 1</b> is executed before the loop (the code block) starts.</p>
				<p><b>Statement 2</b> defines the condition for running the loop (the code block).</p>
				<p><b>Statement 3</b> is executed each time after the loop (the code block) has been executed.</p>
				<p>Example (outputs <c>"0123456789"</c>):</p>
				<c><![CDATA[
					var i;
					for (i = 0; i < 10; i++) {
						print(i);
					}]]>
				</c>
				<p>From the example above, you can read:</p>
				<p>Statement 1 sets a variable before the loop starts (<c>i = 0</c>).</p>
				<p>Statement 2 defines the condition for the loop to run (<c>i</c> must be less than 10).</p>
				<p>Statement 3 increases a value (<c>i++</c>) each time the code block in the loop has been executed.</p>
				<s name="Statement 1">
					<p>Normally you will use statement 1 to initialize the variable used in the loop (<c>i = 0</c>). This is not always the case, Goat doesn't care. Statement 1 is optional. You can omit statement 1 (like when your values are set before the loop starts):</p>
					<c><![CDATA[
						var i = 0;
						for (; i < 10; i++) {
							print(i);
						}]]>
					</c>
					<p>Also, you can declare a variable in statement 1 using <c>var</c> keyword:</p>
					<c><![CDATA[
						for (var i = 0; i < 10; i++) {
							print(i);
						}]]>
					</c>
					<p>This variable will be visible only inside the 'for' loop.</p>
				</s>
				<s name="Statement 2">
					<p>Often statement 2 is used to evaluate the condition of the initial variable. This is not always the case, Goat doesn't care. Statement 2 is also optional. If statement 2 returns <c>true</c>, the loop will start over again, if it returns <c>false</c>, the loop will end.</p>
					<p>If you omit statement 2, you must provide a <c>break</c> or a <c>return</c> inside the loop. Otherwise the loop will never end.</p>
				</s>
				<s name="Statement 3">
					<p>Often statement 3 increments the value of the initial variable. This is not always the case, Goat doesn't care, and statement 3 is optional. Statement 3 can do anything like negative increment (<c>i--</c>), positive increment (<c>i = i + 15</c>), or anything else. Statement 3 can also be omitted (like when you increment your values inside the loop):</p>
					<c><![CDATA[
						for (i = 0; i < 10; ) {
							print(i);
							i++;
						}]]>
					</c>
				</s>
			</s>
			<s name="The 'for..in' loop">
				<p>The Goat <c>for..in</c> statement loops through the properties of an object:</p>
				<c><![CDATA[
					var person = {name: "Ivan", age: 33, gender: "male"};
					var x;
					for (x in person) {
						print(x + ": " + person[x] + "\n");
					}]]>
				</c>
				<p>Output:</p>
				<c><![CDATA[
					name: Ivan
					age: 33
					genger: male]]>
				</c>
				<p>Note that objects store unordered pairs <c>key:value</c>. The order of traversal of object properties may not match with the order of the properties at object creation. In the example above, the output can be:</p>
				<c><![CDATA[
					age: 33
					name: Ivan
					genger: male]]>
				</c>
			</s>
			<s name="The 'while' loop">
				<p>The <c>while</c> loop loops through a block of code as long as a specified condition is <c>true</c>. Syntax:</p>
				<c><![CDATA[
					while (condition) {
						code block to be executed
					}]]>
				</c>
				<p>Example  (outputs <c>"0123456789"</c>):</p>
				<c><![CDATA[
					var i = 0;
					while (i < 10) {
						print(i);
						i++;
					}]]>
				</c>
				<p>Note: if you forget to increase the variable used in the condition, the loop will never end.</p>
			</s>
			<s name="The 'do..while' loop">
				<p>The <c>do..while</c> loop is a variant of the while loop. This loop will execute the code block once, before checking if the condition is <c>true</c>, then it will repeat the loop as long as the condition is <c>true</c>. Syntax:</p>
				<c><![CDATA[
					do {
						code block to be executed
					}
					while (condition);]]>
				</c>
				<p>Example. The loop will always be executed at least once, even if the condition is <c>false</c>, because the code block is executed before the condition is tested:</p>
				<c><![CDATA[
					var i = 0;
					do {
						print(i);
						i++;
					} while (i < 10);]]>
				</c>
			</s>
			<s name="The 'break' statement">
				<p>You have already seen the <c>break</c> statement used in an earlier chapter of this tutorial. It was used to "jump out" of a <c>switch</c> statement. The <c>break</c> statement can also be used to "jump out" of a loop. The <c>break</c> statement breaks the loop and continues executing the code after the loop (if any):</p>
				<c><![CDATA[
					var i;
					for (i = 0; i < 10; i++) {
						if (i == 6)
							break;
						print(i);
					}]]>
				</c>
				<p>Output: <c>012345</c>.</p>
			</s>
			<s name="The 'continue' statement">
				<p>The <c>continue</c> statement breaks one iteration (in the loop), if a specified condition occurs, and continues with the next iteration in the loop.</p>
				<p>This example skips the value of 3:</p>
				<c><![CDATA[
					var i;
					for (i = 0; i < 10; i++) {
						if (i == 3)
							continue;
						print(i);
					}]]>
				</c>
				<p>Output: <c>012456789</c>.</p>
			</s>
		</s>
		<s name="Exceptions">
			<s name="Errors will happen!">
				<p>When executing Goat code, different errors can occur. For example, division by zero:</p>
				<c>print(1 / 0); // oops</c>
			</s>
			<p>The <c>try</c> statement lets you test a block of code for errors.</p>
			<p>The <c>catch</c> statement lets you handle the error.</p>
			<p>The <c>throw</c> statement lets you create custom errors.</p>
			<p>The <c>finally</c> statement lets you execute code, after try and catch, regardless of the result.</p>
			<s name="Try and catch">
				<p>The <c>try</c> statement allows you to define a block of code to be tested for errors while it is being executed.</p>
				<p>The <c>catch</c> statement allows you to define a block of code to be executed, if an error occurs in the try block.</p>
				<p>The Goat statements <c>try</c> and <c>catch</c> come in pairs:</p>
				<c><![CDATA[
					try {
						Block of code to try
					}
					catch(err) {
						Block of code to handle errors
					}]]>
				</c>
				<p>Example:</p>
				<c><![CDATA[
					try {
						print(4 / 4);
						print(4 / 2);
						print(4 / 1);
						print(4 / 0);
					}
					catch(err) {
						print("Error");
					}]]>
				</c>
				<p>Output:</p>
				<c>124Error</c>
				<p>When an error occurs, Goat will normally stop and generate an error object. The technical term for this is: Goat will <b>throw an exception</b> (throw an error).</p>
			</s>
			<s name="The 'throw' statement">
				<p>The <c>throw</c> statement allows you to create a custom error.</p>
				<p>Technically you can <p>throw an exception</p> (throw an error). The exception can be any object:</p>
				<c>throw "Oops!"; // throw a string</c>
				<p>The thrown object passes as parameter of the <c>catch</c> statement.</p>
				<p>If you use <c>throw</c> together with <c>try</c> and <c>catch</c>, you can control program flow and generate custom error messages.</p>
				<c><![CDATA[
					var kelvin2Celsius = function(value) {
						if (value < 0)
							throw "Wrong parameter: " + value;
						
						return value -273.15;
					};
					
					try {
						print("\n" + kelvin2Celsius(300));
						print("\n" + kelvin2Celsius(0));
						print("\n" + kelvin2Celsius(-10));
					}
					catch(err) {
						print("\n" + err);
					}]]>
				</c>
				<p>Output:</p>
				<c><![CDATA[
					26.85
					-273.15
					Wrong parameter: -10]]>
				</c>
			</s>
			<s name="The 'finally' statement">
				<p>The finally statement lets you execute code, after try and catch, regardless of the result:</p>
				<c><![CDATA[
					try {
						Block of code to try
					}
					catch(err) {
						Block of code to handle errors
					} 
					finally {
						Block of code to be executed regardless of the try / catch result
					}]]>
				</c>
			</s>
			<s name="The error object">
				<p>The exception can be any object. For some situations, the interpreter throws predefined exception objects, such as:</p>
				<t>
					<h>
						<c>Exception</c>
						<c>Situation</c>
					</h>
					<r>
						<c><c>NameIsNotDefined</c></c>
						<c>Attempt to call a function with an undefined name. For example, <c>Print</c> (first capital letter) instead of <c>print</c></c>
					</r>
					<r>
						<c><c>IsNotAFunction</c></c>
						<c>Attempt to call a function: name is defined, but it is not a function.<c>var f = 0; f();</c></c>
					</r>
					<r>
						<c><c>OperatorIsNotDefined</c></c>
						<c>Attempt to use an operator that is not applicable to this data type. For example, you can not multiply strings: <c>"hello" * "world"</c></c>
					</r>
					<r>
						<c><c>DivisionByZero</c></c>
						<c>Division by zero, <c>print(1 / 0);</c></c>
					</r>
					<r>
						<c><c>IncorrectIndex</c></c>
						<c>Index of an array is not an integer, <c>var a = [0, 13, 666]; print(a["0"]);</c></c>
					</r>
					<r>
						<c><c>OutOfBounds</c></c>
						<c>Index of an array is too big , <c>var a = [0, 13, 666]; print(a[10]);</c></c>
					</r>
					<r>
						<c><c>IllegalArgument</c></c>
						<c>Wrong argument of a function or an operator</c>
					</r>
				</t>
				<p>Each object (include error objects) has the <c>instanceOf</c> method. You can use this method to determine the type of exception:</p>
				<c><![CDATA[
					try {
						// do something
					}
					catch(err) {
						if (err.instanceOf(Exception.OutOfBounds)) {
							// do domething if out of bounds
						}
					}]]>
				</c>
			</s>
		</s>
		<s name="Import">
			<s name="Overview">
			<p>Sometimes the program becomes so large that it is more reasonable to separate it into several files. In addition, you can use pre-designed libraries - say, to recognize XML files. Goat provides a way to include files to a program using an <c>import</c> keyword.</p>
			<c><![CDATA[
				import "xml.goat";
				
				// now, you can use functions from XML library:
				var root = XML.parse("<root></root>");]]>
			</c>
			<p>No file will be imported twice. For example, your program uses library <c>A</c> and library <c>B</c>. But library <c>B</c> uses (imports) library <c>A</c> also. So, library <c>A</c> will be imported only once, for all project.</p>
			<p>Where the interpreter finds files to import? </p>
			<l>
				<i>first, in the current folder, where was started Goat script;</i>
				<i>second, in the list of folders specified in the <c>--lib</c> option of the interpreter.</i>
			</l>
			</s>
			<s name="--lib option">
				<p>Path (paths) to importable files. For example, folder <c>c:\goat\lib</c> contains Goat standard library; so, to use it, launch the interpreter with <c>--lib</c> option:</p>
				<c>goat.exe program.goat --lib=c:\goat\lib</c>
				<p>Several paths can be separated by a semicolon. The interpreter for each imported file first searches the first path in the list, then the second one, and so on.</p>
			</s>
		</s>
		<s name="Debugging">
			<s name="Interactive mode">
				<p>Goat has two basic modes: script and interactive. The normal mode is the mode where the scripted and finished files are run in the Goat interpreter. Interactive mode is a command line shell which gives immediate feedback for each statement while running previously fed statements in active memory. As new lines are fed into the interpreter, the fed program is evaluated both in part and in whole.</p>
				<p>To start interactive mode, launch the Goat interpreter without script file (in common cases without any parameters):</p>
				<c>goat.exe</c>
				<p>Will open a console:</p>
				<c>?</c>
				<p>Enter any correct statement and press Enter:</p>
				<c><![CDATA[
					? var i = 0;
					
					?]]>
				</c>
				<p>In the example above, the interpreter will create a variable <c>i</c> and wait for the new statement to be entered. So, now you can print the value of the variable:</p>
				<c><![CDATA[
					? print(i);
					0
					?]]>
				</c>
				<p>You can use any statements you want:</p>
				<c><![CDATA[
					? for (var k = 0; k < 10; k++) print(k);
					0123456789
					?]]>
				</c>
				<p>If statement takes more than one line, add a backslash to go a new line:</p>
				<c><![CDATA[
					? for (var k = 0; k < 10; k++) { \
						if (k == 3) continue; \
						print(k); \
					}
					012456789
					?]]>
				</c>
				<p>The values of all variables are saved:</p>
				<c><![CDATA[
					? var obj = {};
					
					? obj.field = 1;
					
					? print(obj);
					{field:1};
					?]]>
				</c>
				<p>The special statement <c>exit</c> exits interactive mode.</p>
				<c>exit</c>
			</s>
			<s name="Step-by-step debugging">
				<s name="The 'debug' keyword">
					<p>The <c>debug</c> keyword stops the execution of Goat, and switch the interpreter to step-by-step mode. If no debugging is available, the <c>debug</c> statement has no effect.</p>
					<c><![CDATA[
						var i, j;
						for (i = 0; i < 10; i++) {
							debug;
							j = i * i;
							print("" + j + "\n");
						}]]>
					</c>
					<p>Then launch the interpreter with <c>--debug</c> option:</p>
					<c>goat.exe program.goat --debug</c>
					<p>The program will start and then stop on <c>debug</c> keyword:</p>
					<c><![CDATA[
						> program.goat, 3.7: debug;
						[step] ?]]>
					</c>
				</s>
				<s name="Step-by-step dialog">
					<p>After stop (and each step) the interpreter outputs step-by-step dialog and wait for a command:</p>
					<c><![CDATA[
						> program.goat, 4.9: j = i * i;
						[step] ?]]>
					</c>
					<p>In the example above, the individual elements of the dialog have the following meanings:</p>
					<t>
						<h>
							<c>Element</c>
							<c>Description</c>
						</h>
						<r>
							<c><c>program.goat</c></c>
							<c>Filename of the current script</c>
						</r>
						<r>
							<c><c>4.9</c></c>
							<c>Current line (4) and symbol in line (9)</c>
						</r>
						<r>
							<c><c>j = i * i;</c></c>
							<c>The expression that will now be executed</c>
						</r>
						<r>
							<c><c>[step]</c></c>
							<c>Command by default</c>
						</r>
						<r>
							<c><c>?</c></c>
							<c>Prompt to enter a command</c>
						</r>
					</t>
					<p>You can enter the following commands:</p>
					<t>
						<h>
							<c>Short command</c>
							<c>Full command</c>
							<c>Description</c>
						</h>
						<r>
							<c><c>c</c></c>
							<c><c>continue</c></c>
							<c>Continue until the next stop on <c>debug</c> statement.</c>
						</r>
						<r>
							<c><c>s</c></c>
							<c><c>step</c></c>
							<c>Next step (over). If this step is a function call, then the function is executed entirely.</c>
						</r>
						<r>
							<c><c>i</c></c>
							<c><c>into</c></c>
							<c>Next step (into). If the next step is a function call, the interpreter "enters inside" the function and then stops at the first statement of the function.</c>
						</r>
						<r>
							<c><c>o</c></c>
							<c><c>out</c></c>
							<c>Next step (out). The interpreter executes the current function to the end and stops at the first statement after calling this function.</c>
						</r>
						<r>
							<c/>
							<c><c>$var_name</c></c>
							<c>Prints the contents of a variable <c>var_name</c>.</c>
						</r>
					</t>
					<p>If you press <c>Enter</c> without entering any command, the default command (in square brackets) will be executed. Typically, the default command is the last command executed.</p>
				</s>
			</s>
		</s>
	</s>
	
	<s name="Advanced programming">
		<p>Forget everything you learned in school.</p>
		<s name="The new look at objects">
			<s name="Keys and values">
				<p>Objects are containers for pairs <c>key:value</c>:</p>
				<c>var person = { firstName : "Scott", lastName : "Cameron", age : 45 };</c>
				<p>The <c>key:value</c> pairs (in Goat objects) are called <b>properties.</b></p>
				<p>Values can be any objects: strings, numbers etc. What about keys? In the example above, keys are identifiers (such as names of variables).In common cases, using identifiers as keys is enough: it is convenient. You always can to add a new property using the dot operator <c>.</c>:</p>
				<c>person.profession = "Programmer";</c>
				<p>But, keys can be not only identifiers. You can use any object as a key. For example, integers:</p>
				<c>person[3] = "value";</c>
				<p>...or booleans:</p>
				<c>person[true] = false;</c>
				<p>...and, of course, strings:</p>
				<c>person["profession"] = "Programmer";</c>
				<p>If you use a string as a key, and this string can be an identifier (the first character must be a letter or an underscore (<c>_</c>), subsequent characters may be letters, digits or underscores), Goat transforms this string to an identifier. Later you can access to this field using identifier:</p>
				<c><![CDATA[
					person["weight"] = 80;
					//...
					print(person.weight); // output: 80]]>
				</c>
				<p>And vice versa, any property declared using an identifier, can be accessed using a string:</p>
				<c><![CDATA[
					person.weight = 80;
					//...
					print(person["weight"]); // output: 80]]>
				</c>
				<p>So, objects are containers for pairs <c>key:value</c>, where the key can be an identifier or any object, and the value can be any object. However, the Goat program works a little faster if you use identifiers as keys, so this is the preferred method.</p>
			</s>
			<s name="Each object has some predefined methods">
				<p>Goat adds these methods to each object.</p>
				<m name="instanceOf" descr="Returns whether an object is derived from another object or not.">
					<a name="object" type="any type" descr="the prototype"/>
					<e><![CDATA[
						var isInteger = $(obj) {
							return obj.instanceOf(Integer);
						};]]>
					</e>
					<n>The method is used to determine the type (more correctly, the prototype) of the object. What is a prototype, will be described a little later.</n>
				</m>
				<m name="clone" descr="Returns a clone of the object, that is, a new object in which all properties are the same as in the source object.">
					<e><![CDATA[
						var a = { name: "Ivan", age: 33 };
						var b = a.clone();
						b.name = "Jonh";
						print(b); // output: {name:"John",age:33}
						print(a); // output: {name:"Ivan",age:33} ]]>
					</e>
					<n>This is required if you need to get a real copy of the object, then change it and leave the original object unchanged.</n>
				</m>
				<m name="flat" descr="Returns a flat object, that is, an object that contains all the properties of the source object, as well as all properties of all prototypes of the source object. What is a prototype, will be described a little later."/>
			</s>
			<s name="Everything is an object">
				<p>All data (strings, numbers, booleans) represented as objects. These are "special" objects that have special behavior. But beyond this, these objects do everything the same as other, "ordinary" objects.</p>
				<p>For example, you can add a property for a string:</p>
				<c><![CDATA[
					var str = "hello!";
					str.somePropertyName = 123;]]>
				</c>
				<p>...or add some method to an integer:</p>
				<c><![CDATA[
					var n = 123;
					n.increment = $(){
						return this + 1;
					}; ]]>
				</c>
				<p>As each object has some predefined methods, strings, booleans, integers, and others also have all these methods:</p>
				<c><![CDATA[
					var str = "hello!";
					print(str.instanceOf(String)); // output: true
					
					var num = 10;
					print(num.instanceOf(Boolean)); // ounput: false]]>
				</c>
			</s>
		</s>
		<s name="Methods">
			<s name="Difference between method and function">
				<p>A <b>method</b> in object-oriented programming is a function associated with an object.</p>
				<p>In other words, functions work only with parameters, but methods also "see" all the properties (fields and other methods) of own object and can modify these.</p>
				<p>Example. Declare an object <c>obj</c> that contains one field <c>x</c> and one method <c>getX</c>. The method can access the field:</p>
				<c><![CDATA[
					var obj = {
						x: 10;
						
						getX : $() {
							return x;
						}
					};
					
					var n = obj.getX(); // 10]]>
				</c>
			</s>
			<s name="Search order">
				<p>Since a property (or variable) with the same name can be defined in many places, the programming language specifies a clear order of searching for the value by name.</p>
				<p>Suppose we want to read a variable named <c>x</c>. The highest priority has local variables:</p>
				<c><![CDATA[
					var obj = {
						x: 10; // property 'x'
						
						getX : $() {
							var x = 2 + 3; // local variable 'x'
							return x;
						}
					};
					
					var n = obj.getX(); // 5 ]]>
				</c>
				<p>If a local variable with this name is not found, the Goat programming language tries to find this name in the list of arguments of the method:</p>
				<c><![CDATA[
					var obj = {
						x: 10; // property 'x'
						
						getX : $(x) { // method with argument named 'x'
							return x;
						}
					};
					
					var n = obj.getX(7); // 7 ]]>
				</c>
				<p>Then the search is performed in the object properties:</p>
				<c><![CDATA[
					var x = 777; // external variable 'x'
					
					var obj = {
						x: 10; // property 'x'
						
						getX : $() {
							return x;
						}
					};
					
					var n = obj.getX(); // 10 ]]>
				</c>
				<p>The last thing to do is look for variables outside the object:</p>
				<c><![CDATA[
					var x = 777; // external variable 'x'
					
					var obj = {
						getX : $() {
							return x;
						}
					};
					
					var n = obj.getX(); // 777 ]]>
				</c>
			</s>
			<s name="The 'this' keyword">
				<p>When a method is called, a special variable named <c>this</c> is always defined. This variable refers to the object whose method was called. You can not overwrite the value of this variable. This variable is used to explicitly access the properties of the "own" object.</p>
				<c><![CDATA[
					var obj = {
						x: 10; // property 'x'
						
						getX : $() {
							return this.x;
						}
					};
					
					var n = obj.getX(); // 10 ]]>
				</c>
				<p>In fact, the example above is completely analogous to this example:</p>
				<c><![CDATA[
					var obj = {
						x: 10; // property 'x'
						
						getX : $() {
							return x; // without 'this' keyword
						}
					};
					
					var n = obj.getX(); // 10 ]]>
				</c>
				<p>That is, in most cases, we can do without using <c>this</c> keyword. But in some cases, <c>this</c> keyword cannot be avoided. For example, if you already have a local variable or an argument with that name, but you want to explicit read or write the property of the object:</p>
				<c><![CDATA[
					var obj = {
						x: 10; // property 'x'
						
						getX : $() {
							return x;
						}
						
						setX " $(x) {
							this.x = x; // read the argument 'x' and write the property 'x' 
						}
					};
					
					obj.setX(777);
					var n = obj.getX(); // 777 ]]>
				</c>
				<p>Or, you can add new properties to own object (which are not yet there):</p>
				<c><![CDATA[
					var obj = {
						x: 10; // property 'x'
						
						init : $() { // constructor
							this.y = 20; // add a new property 'y'
						}
					};]]>
				</c>
			</s>
		</s>
		<s name="Prototypes">
			<s name="Prototype and inheritance">
				<p>Goat is prototype-oriented language. What is "prototype" means?</p>
				<p>A <b>prototype</b> is an object from which other objects <b>inherit</b> properties and methods. Any object can be a prototype for another object.</p>
				<p><b>Inheritance</b> is when an object is based on another object using the same implementation.</p>
				<p>How does it work? When accessing an object (method call or field reading), the Goat programming language first looks for this property in the object itself. If Goat does not find it, tries to look for this property in the prototype object. If still not found, then Goat is searching in a prototype of the prototype, and so on.</p>
				<c><![CDATA[
					// declare an object:
					var parent = { x: 1 };
					
					// inherit another object:
					var child = parent -> { y: 2, z: 3 }; 
					
					// now you have access to properties in the parent object:
					print(child.x); // output: 1]]>
				</c>
			</s>
			<s name="Operator -&gt;">
				<p>Operator <c>-&gt;</c> builds a new object from the <b>prototype</b> and <b>description:</b></p>
				<c>var obj = prototype -&gt; description;</c>
				<p>A <b>prototype</b> is any object from which properties (fields and methods) will be used if properties with such names are not found in the child object.</p>
				<p>A <b>description</b> is an object that will be cloned before a prototype is attached to it. The description thus <b>extends</b> the prototype, and as a result, a new object is created that contains both its own properties and the properties of all its parents.</p>
				<p>Example:</p>
				<c><![CDATA[
					// declare an object:
					var A = { x: 1 };
					
					// inherit:
					var B = A -> { y: 2, z: 3 }; // 'B' contains 'x', 'y' and 'z' ]]>
				</c>
				<p>Of course, you can declare a description elsewhere:</p>
				<c><![CDATA[
					// declare an object:
					var A = { x: 1 };
					
					// declare a description:
					var D = { y: 2, z: 3 };
					
					// inherit:
					var B = A -> D; // 'B' still contains 'x', 'y' and 'z' ]]>
				</c>
			</s>
			<s name="Prototype сhain">
				<p>If you created a new object using an operator <c>-&gt;</c>, then this object, in turn, can also be a prototype of some other object:</p>
				<c><![CDATA[
					// declare an object:
					var A = { x: 1 };
					
					// inherit first time:
					var B = A -> { y: 2 }; // 'B' contains 'x' and 'y' 
					
					// inherit second time:
					var C = B -> { z: 3 }; // 'C' contains 'x', 'y' and 'z' ]]>
				</c>
				<p>The Goat programming language looks for the property by its name along the whole prototype chain, from last to first prototype. For example,</p>
				<c>print(C.x);</c>
				<p>The order of search is:</p>
				<l>
					<i>first, a property named <c>x</c> will be searched in the <c>C</c> object and will not be found;</i>
					<i>second, a property will be searched in the <c>B</c> object and will not be found;</i>
					<i>finally, a property will be searched in the <c>A</c> object and will be found.</i>
				</l>
				<p>Another example, attempt to read an undefined property:</p>
				<c>print(C.w);</c>
				<p>In this case, the Goat programming language will scan the whole prototype chain (first <c>C</c>, then <c>B</c>, then <c>A</c>), but will not find the properties and return <c>undefined</c> result.</p>
			</s>
			<s name="Changing the prototype">
				<p>You can not change the prototype of the object. Instead, you can change properties of the prototype itself. In this case, these properties will immediately change in all children:</p>
				<c><![CDATA[
					// declare an object:
					var A = { x: 1 };
					
					// inherit:
					var B = A -> { y: 2, z: 3 }; 
					
					// read the value of 'x' property (of the child object):
					print(B.x); // output: 1
					
					// change the value of 'x' property (in the parent object):
					A.x = 777;
					
					// read the value of 'x' property again:
					print(B.x); // output: 777]]>
				</c>
			</s>
			<s name="Overriding">
				<p>You can override properties (fields and methods) in children objects.</p>
			</s>
			<s name="Multiple inheritance">
				<p>Objects in the Goat programming language can have more than one prototype.</p>
			</s>
			<s name="The 'instanceOf' method">
				<p>The method checks whether there is an object passed as an argument in the prototype chain.</p>
			</s>
			<s name="The 'clone' method">
				<p>Returns a clone of the object, that is, a new object in which all properties are the same as in the source object.</p>
				<p><b>Do not use <c>clone</c> method, inherit an object instead!</b> Cloning is a very expensive operation, due to the need to copy each field.</p>
			</s>
			<s name="The 'flat' method">
				<p>Returns a flat object, that is, an object that contains all the properties of the source object, as well as all properties of all prototypes of the source object.</p>
			</s>
			<s name="Prototypes of built-in types">
				<p>Each object of built-in type (string, integer etc) has own built-in prototype.</p>
			</s>
		</s>
	</s>
	
	<s name="Standard library">
		<p>The standard library contains functions and classes for solving common tasks.</p>
		<p>All the functionality of the standard library is divided into two parts: <b>internal</b> (as part of the interpreter core) and <b>external.</b></p>
		<p>The functionality of the inner part of the library is written in C++ language and is the minimum required set for solving most tasks. This functionality includes platform-dependent components, such as working with files. No additional modules are required to use the internal library, these classes and functions are always available.</p>
		<p>The external library is written in Goat language. It is a set of files that contain separate classes for solving various tasks. To use this class from the library, you need to link the corresponding file using the <c>import</c> keyword.</p>
		<s name="Internal (core) library">
			<s name="Functions">
				<s name="Input/output">
					<m name="print" descr="Converts an object to a string and sends this string to standard output.">
						<a name="object" type="any type" descr="an object"/>
						<e><![CDATA[
							print("Hello");
							print(2 + 3);
							print(0.01);
							print(false);
							print(null);]]>
						</e>
					</m>
					<m name="open" descr="Opens a file.">
						<a name="fname" type="String" descr="file name"/>
						<a name="mode" type="File.Mode" descr="mode, one of: File.Mode.READ, File.Mode.WRITE or File.Mode.APPEND"/>
						<e><![CDATA[
							var file = open("reference.xml", File.Mode.READ);
							var data = file.read(256); // read first 256 bytes]]>
						</e>
						<n>See description of 'File' class for more details.</n>
					</m>
				</s>
				<s name="Other">
					<m name="defined" descr="Returns 'true' if the object is defined (i.e. not equals 'undefined'), and 'false' otherwise.">
						<a name="object" type="any type" descr="an object"/>
						<e><![CDATA[
							var func = $(param) {
								if (!defined(param)) {
									return;
								}
								
								//...
							};]]>
						</e>
					</m>
					<m name="clock" descr="Returns current system time in nanoseconds.">
						<e><![CDATA[
							var wait = $(time) {
								var begin = clock();
								var diff = 0;
								do {
									diff = clock() - begin;
								} while(diff < time * 1000000000);
							};

							var i;
							for (i = 5; i > 0; i--) {
								print("" + i + "\n");
								wait(1);
							}
							]]>
						</e>
						<n>The example shows a simple implementation of delay and countdown using the 'clock' function. The function returns the time span value between the begin of the 'system epoch' (it depends from the platform) and the current time point. In itself, this value is useless, as a rule, the difference between the two clock values is used.</n>
					</m>
				</s>
			</s>
			<s name="Classes">
				<s name="Input/output">
					<p>To be done</p>
				</s>
				<s name="Strings">
					<s name="StringBuilder">
						<p>The class for strings constructing.</p>
						
					</s>
				</s>
			</s>
		</s>
		<s name="External library">
			<p>To be done.</p>
		</s>
	</s>
	
	<s name="In comparison with JavaScript">
		<p>The Goat programming language based in general on JavaScript, but it has some differences.</p>
		<l>
			<i>The interpreter (engine) of the programming language is not a complement to the existing solutions, say, V8. It is completely developed from scratch. The interpreter is very small program and can be compiled and started in different platforms. I tried  Windows and Linux (both x86 and ARM). All you need are C++11 compiler and standard C library (libc etc).</i>
			<i>Programs are launched not in a browser, not in a special environment (say Node.js); you can write general-purpose applications. Easy to install: just copy the file with your code and interpreter and then start.</i>
			<i>The syntax is more simple, the object model is more unified.</i>
			<i>Goat language supports multi-threading and operators overloading.</i>
			<i>You can create an object from more than one prototype.</i>
		</l>
		<p>Some samples are below.</p>
		
		<s name="Identifiers">
			<h name="JavaScript">
				<p>The first character of an identifier must be a letter, or an underscore (<c>_</c>), or a dollar sign (<c>$</c>). Subsequent characters may be letters, digits, underscores, or dollar signs.</p>
			</h>
			<h name="Goat">
				<p>The first character must be a letter or an underscore (<c>_</c>). Subsequent characters may be letters, digits or underscores.</p>
				<p>Dollar sign used as a short replacement of <c>function</c> keyword:</p>
				<c>var f = $(a, b) { };</c>
				<p>it's the same as:</p>
				<c>var f = function(a, b) { };</c>
			</h>
		</s>
		
		<s name="Keywords">
			<p>The Goat programming language reserves several additional keywords:</p>
			<t>
				<h>
					<c>Keyword</c>
					<c>Description</c>
				</h>
				<r>
					<c><c>thread</c></c>
					<c>Declares a thread</c>
				</r>
				<r>
					<c><c>import</c></c>
					<c>Imports a source file</c>
				</r>
				<r>
					<c><c>debug</c>(instead of <c>debugger</c>)</c>
					<c>Stops the execution of Goat script, and switch the interpreter to debug (step-by-step) mode</c>
				</r>
			</t>
		</s>
		
		<s name="Operators">
			<p>The Goat language has no comparison operators <c>===</c> (equal value and equal type) and <c>!==</c> (not equal value or not equal type). Operators <c>==</c> and <c>!=</c> works in most cases as <c>===</c> and <c>!==</c> operators in JavaScript.</p>
			<p>The Goat language has not <c>typeof</c> and <c>instanceof</c> operators. Use <c>instanceOf</c> method instead:</p>
			<c>print(13.instanceOf(Integer)); // output: "true"</c>
			<p>The Goat language provides the new operator <c>-&gt;</c> that means inheritance.</p>
		</s>
		
		<s name="Primitive types">
			<h name="JavaScript">
				A primitive data type is a data that is not an object and has no methods. There are 6 primitive data types: string, number, boolean, null, undefined, symbol. All primitives are immutable.
			</h>
			<h name="Goat">
				<p>There are no primitive types. All data represented as objects. Each object except <c>undefined</c> has some methods. There are some predefined objects which are prototypes for primitive data, such as numbers or strings: <c>Char</c>, <c>String</c>, <c>Integer</c>, <c>Real</c>, <c>Boolean</c> and <c>Null</c>.</p>
				<p>This programming language clearly distinguishes between strings (prototype is <c>String</c>) and individual characters (prototype is <c>Char</c>), as well as integers (<c>Integer</c>) and floating-point numbers (<c>Real</c>). These types have different set of methods and operators, but if necessary type can be converted to another:</p>
				<c><![CDATA[
					var c = 'a'; // prototype of c is Char
					var s = String.valueOf(c); // conversion to String]]>
				</c>
				<p>All other structures, for example, functions, threads, arrays etc have own prototypes (<c>Function</c>, <c>Thread</c>, <c>Array</c>).</p>
			</h>
		</s>
		
		<s name="Scope">
			<h name="JavaScript">
				<p>There are two types of scopes: global and local. Variables defined inside a function are in the local scope. Variables defined inside of a block statement will remain in the scope they were already in. ECMAScript 6 introduced the <c>let</c> keyword. Contrary to the <c>var</c> keyword, the <c>let</c> keyword supports the declaration of local scope inside block statements.</p>
				<c><![CDATA[
					var func = function() {
						var v = 0;
						// do something...
						if (true) {
							let v = 1; // local declaration
						}
					};]]>
				</c>
				<p>If you re-declare a JavaScript variable in the same block, it will not lose its value.</p>
			</h>
			<h name="Goat">
				<p>There is no global scope. You can re-declare variable with the same name in inner block statement, it will be used only in this block.</p>
				<c><![CDATA[
					var func = $() {
						var v = 0;
						if (true) {
							var v = 1;
							print(v); // output: "1"
						}
						print(v); // output: "0"
					};]]>
				</c>
				<p>But, if you re-declare a Goat variable in the same block, it will lose its value.</p>
			</h>
		</s>
		
		<s name="The 'this' keyword">
			<h name="JavaScript">
				<p>You must use the <c>this</c> keyword to refer to the field of own object:</p>
				<c><![CDATA[
					var MyClass = function() {
						this.x = 0;
					};
					
					MyClass.prototype.getX = function() {
						return this.x;
					};]]>
				</c>
			</h>
			<h name="Goat">
				<p>You can use the <c>this</c> keyword to refer to the field of own object, but you must not do it in all cases. You can skip this keyword in the methods. But in some cases, <c>this</c> keyword cannot be avoided, for example, if you already have a local variable or an argument with that name, but you want to explicit read or write the property of the object, or, you can add new properties to own object (which are not yet there):</p>
				<c><![CDATA[
					var MyClass = {
						init : $() {
							this.x = 0; // with 'this'
						},
						
						getX : $() {
							return x; // without 'this'
						}
					};]]>
				</c>
			</h>
		</s>
		
		<s name="Operators overloading">
			<h name="JavaScript">
				<p>Doesn't support.</p>
			</h>
			<h name="Goat">
				<p>You can use the operator as method name:</p>
				<c><![CDATA[
					var Vector = {
						init : $(x, y) {
							this.x = x; this.y = y
						},
						toString : $() {
							return "X: " + x + ", Y: " + y;
						},
						"+" : $(vec) {
							return new Vector(x + vec.x, y + vec.y);
						},
						"*" : $(val) {
							return new Vector(x * val, y * val);
						}
					};

					var v1 = new Vector(100, 200);
					var v2 = new Vector(200, 400);

					print((v1 + v2).toString()); // output: "X: 300, Y: 600"
					print(' ');
					print((v1 * 5).toString()); // output: "X: 500, Y: 1000";]]>
				</c>
			</h>
		</s>
		
		<s name="Multithreading">
			<h name="JavaScript">
				<p>Doesn't support. There are some workarounds, say web workers, and, of course, functions <c>setTimeout()</c> and <c>setInterval()</c>.</p>
			</h>
			<h name="Goat">
				<p>There is <c>thread</c> keyword. It possible to declare any function as a separate thread.</p>
				<c><![CDATA[
					var t0 = thread(){
						while(true) {
							print('A');
						}
					};

					var t1 = thread(){
						while(true) {
							print('B');
						}
					};

					t0.run();
					t1.run();

					// Output: "ABABABABABABAB...."]]>
				</c>
			</h>
		</s>

		<s name="The 'new' keyword and constructors">
			<h name="JavaScript">
				<p>Constructors are like regular functions, but we use them with the <c>new</c> keyword. If you inherit your object and the parent has a constructor, you need to call parent constructor to perform initialization logic.</p>
				<c><![CDATA[
					var A = function() {
						// init something...
					};

					var B = function() {
						A.apply(this);
						// init something else...
					};
					B.prototype = new A();]]>
				</c>
			</h>
			<h name="Goat">
				<p>There is special method <c>init()</c>. If method defined, interpreter call it. If method also defined in base object, interpreter call it first (order of calling constructors as in C++).</p>
				<c><![CDATA[
					var A = {
						init : $() {
							// init something...
						}
					};

					var B = A -> {
						init : $() {
							// init something else...
						}
					};

					var obj = new B(); /* both init method will be called,
										  first from A, second from B */]]>
				</c>
			</h>
		</s>

		<s name="Inheritance">
			<h name="JavaScript">
				<c><![CDATA[
					var A = function() {
						this.x = 0;
					};

					var B = function() {
						A.apply(this);
						this.y = 1;
					};
					B.prototype = new A();

					var C = function() {
						B.apply(this);
						this.z = 2;
					};
					C.prototype = new B();]]>
				</c>
				<p>Nearly all objects in JavaScript are instances of <c>Object</c>, a typical object inherits properties (including methods) from <c>Object.prototype</c>.</p>
			</h>
			<h name="Goat">
				<p>The syntax is much simpler. Use operator <c>-&gt;</c>:</p>
				<c><![CDATA[
					var A = {
						x : 0
					};

					var B = A -> {
						y : 1
					};

					var C = B -> {
						z : 2
					};]]>
				</c>
				<p>Goat language has not class (prototype) named <c>Object</c> (is the root of the class hierarchy in Java and prototype hierarchy in JavaScript). Objects have not a super-prototype. An object has prototype if it created from literal (for example, strings), or it created by new keyword, or if prototype(s) is explicitly specified when creating an object:</p>
				<c><![CDATA[
					var A = { }; // A has no prototypes 
					var S = "hello"; // the prototype of 'S' is 'String'
					var B = new A(); // the prototype of 'B' is 'A'
					var C = B->{ }; // the prototype of 'C' is 'B']]>
				</c>
			</h>
		</s>
		
		<s name="Multiple inheritance">
			<h name="JavaScript">
				<p>Is not supported. You can use some tricks (say mixins) but it is not true multiple inheritance.</p>
			</h>
			<h name="Goat">
				<p>Why not.</p>
				<c><![CDATA[
					var A = {
						x : 0
					};

					var B = {
						y : 1
					};

					var C = [A, B] -> {
						z : 2
					};]]>
				</c>
				<p>The solution of the problem of multiple inheritance ("the diamond problem"): Goat uses the list of prototypes to inherit from as an ordered list. The interpreter uses the first method it finds by depth-first searching.</p>
			</h>
		</s>	
	</s>
</goat>
