<goat>
	<v value="0.2 &quot;Goatling&quot;"/>
	<s name="Introduction">
		<p><b>Goat</b> is a high-level, dynamic, weakly typed, prototype-based, multi-paradigm, and interpreted programming language, based on JavaScript. It supports the basic functionality of JavaScript, but in addition, it adds support for multithreading, multiple inheritance, operator overloading (all as in C ++), simplified syntax, and so on.</p>
		<p>Why "Goat"? At first, I wanted to name this programming language as "Go", but unfortunately, some little-known company (it seems "Google" or something like that) has already developed a programming language with that name. After a while, when I programmed this interpreter on a laptop lying in a hammock, I was suddenly bitten by my goat. I thought that once the name "Go" is occupied, then perhaps the name "Goat" is no worse. I immediately named the project folder this name and since then it has not changed.</p>
	</s>
	
	<s name="Where to download the latest release?">
		<p>On GitHub: <url>https://github.com/kniazkov/goat/releases/latest</url>.</p>
	</s>
	
	<s name="How to launch Goat script">
		<s name="Quick start">
			<p>Just download the executable file, open console, type executable name and specify a script file name as a parameter:</p>
			<c>goat.exe program.goat</c>
		</s>
		<s name="Command line parameters">
			<p>The Goat interpreter parses command line arguments as follows. All arguments started with two hyphens are internal parameters of the interpreter ("options"). The first argument which is not an option is the name of the script file. All next arguments send to script.</p>
			<p>For example,</p>
			<c>goat.exe --lib=../lib program.goat arg1 arg2</c>
			<p>or, the same thing:</p>
			<c>goat.exe program.goat --lib=../lib arg1 arg2</c>
			<p>or:</p>
			<c>goat.exe program.goat arg1 arg2 --lib=../lib</c>
			<p>where: <c>goat.exe</c> is Goat executable, <c>program.goat</c> is name of the script, <c>--lib=../lib</c> is option of the interpterer, <c>arg1</c> and <c>arg2</c> are arguments of the script.</p>
			<p>Here is a list of interpreter options:</p>
			<h name="--lib">
				<p>Path (paths) to external libraries (to importable files). For example, a path to the Goat standard library. Several paths can be separated by a semicolon.</p>
				<c>goat.exe program.goat --lib=c:\goat\lib;c:\project</c>
			</h>
			<h name="--debug">
				<p>The Goat interpreter launched in debug mode. It means that interpretation will stop and set step-by-step mode when the interpreter executes <c>debug;</c> statement.</p>
			</h>
			<h name="--gc">
				<p>One of three modes of garbage collection. <c>--gc=serial</c> enable serial mode, it means that the garbage collector periodically stops all threads (but it takes low processor resources for collection and has small memory overhead). <c>--gc=parallel</c> does not stop threads (but it constantly uses some processor resources and also it uses some extra memory), this mode enabled by default. <c>--gc=debug</c> used for debugging purposes for interpreter developer, it calls collector after each statement of a script and this is <b>very</b> slow.</p>
				<p>If you don't know what "garbage collection" means, please do not use this parameter, parallel collector is okay for most purposes.</p>
			</h>
		</s>
	</s>
	
	<s name="In comparison with JavaScript">
		<p>The Goat programming language based in general on JavaScript, but it has some differences.</p>
		<l>
			<i>The interpreter (engine) of the programming language is not a complement to the existing solutions, say, V8. It is completely developed from scratch. The interpreter is very small program and can be compiled and started in different platforms. I tried  Windows and Linux (both x86 and ARM). All you need are C++11 compiler and standard C library (libc etc).</i>
			<i>Programs are launched not in a browser, not in a special environment (say Node.js); you can write general-purpose applications. Easy to install: just copy the file with your code and interpreter and then start.</i>
			<i>The syntax is more simple, the object model is more unified.</i>
			<i>Goat language supports multi-threading and operators overloading.</i>
			<i>You can create an object from more than one prototype.</i>
		</l>
		<p>Some samples are below.</p>
		
		<s name="Primitive types">
			<h name="JavaScript">
				A primitive data type is a data that is not an object and has no methods. There are 6 primitive data types: string, number, boolean, null, undefined, symbol. All primitives are immutable.
			</h>
			<h name="Goat">
				<p>There are no primitive types. All data represented as objects. Each object except <c>undefined</c> has some methods. There are some predefined objects which are prototypes for primitive data, such as numbers or strings: <c>Char</c>, <c>String</c>, <c>Integer</c>, <c>Real</c>, <c>Boolean</c> and <c>Null</c>.</p>
				<p>For determine what the type (prototype) of expression, use <c>instanceOf()</c> method:</p>
				<c>
					print(13.instanceOf(Integer)); // output: "true"
				</c>			
			</h>
		</s>
		
		<s name="Scope">
			<h name="JavaScript">
				<p>There are two types of scopes: global and local. Variables defined inside a function are in the local scope. Variables defined inside of a block statement will remain in the scope they were already in. ECMAScript 6 introduced the <c>let</c> keyword. Contrary to the <c>var</c> keyword, the <c>let</c> keyword supports the declaration of local scope inside block statements.</p>
				<c><![CDATA[
					var func = function() {
						var v = 0;
						// do something...
						if (true) {
							let v = 1; // local declaration
						}
					};]]>
				</c>
			</h>
			<h name="Goat">
				<p>There is no global scope. You can re-declare variable with the same name in block statement, it will be used only in this block.</p>
				<c><![CDATA[
					var func = $() {
						var v = 0;
						if (true) {
							var v = 1;
							print(v); // output: "1"
						}
						print(v); // output: "0"
					};]]>
				</c>
			</h>
		</s>
		
		<s name="Operators overloading">
			<h name="JavaScript">
				<p>Doesn't support.</p>
			</h>
			<h name="Goat">
				<p>You can use the operator as method name:</p>
				<c><![CDATA[
					var Vector = {
						init : $(x, y) {
							this.x = x; this.y = y
						},
						toString : $() {
							return "X: " + x + ", Y: " + y;
						},
						"+" : $(vec) {
							return new Vector(x + vec.x, y + vec.y);
						},
						"*" : $(val) {
							return new Vector(x * val, y * val);
						}
					};

					var v1 = new Vector(100, 200);
					var v2 = new Vector(200, 400);

					print((v1 + v2).toString()); // output: "X: 300, Y: 600"
					print(' ');
					print((v1 * 5).toString()); // output: "X: 500, Y: 1000";]]>
				</c>
			</h>
		</s>
		
		<s name="Multithreading">
			<h name="JavaScript">
				<p>Doesn't support. There are some workarounds, say web workers, and, of course, functions <c>setTimeout()</c> and <c>setInterval()</c>.</p>
			</h>
			<h name="Goat">
				<p>There is <c>thread</c> keyword. It possible to declare any function as a separate thread.</p>
				<c><![CDATA[
					var t0 = thread(){
						while(true) {
							print('A');
						}
					};

					var t1 = thread(){
						while(true) {
							print('B');
						}
					};

					t0.run();
					t1.run();

					// Output: "ABABABABABABAB...."]]>
				</c>
			</h>
		</s>

		<s name="'new' keyword and constructors">
			<h name="JavaScript">
				<p>Constructors are like regular functions, but we use them with the <c>new</c> keyword. If you inherit your object and the parent has a constructor, you need to call parent constructor to perform initialization logic.</p>
				<c><![CDATA[
					var A = function() {
						// init something...
					};

					var B = function() {
						A.apply(this);
						// init something else...
					};
					B.prototype = new A();]]>
				</c>
			</h>
			<h name="Goat">
				<p>There is special method <c>init()</c>. If method defined, interpreter call it. If method also defined in base object, interpreter call it first (order of calling constructors as in C++).</p>
				<c><![CDATA[
					var A = {
						init : $() {
							// init something...
						}
					};

					var B = A -> {
						init : $() {
							// init something else...
						}
					};

					var obj = new B(); /* both init method will be called,
										  first from A, second from B */]]>
				</c>
			</h>
		</s>

		<s name="Inheritance">
			<h name="JavaScript">
				<c><![CDATA[
					var A = function() {
						this.x = 0;
					};

					var B = function() {
						A.apply(this);
						this.y = 1;
					};
					B.prototype = new A();

					var C = function() {
						B.apply(this);
						this.z = 2;
					};
					C.prototype = new B();]]>
				</c>
			</h>
			<h name="Goat">
				<p>The syntax is much simpler. Use operator <c>-&gt;</c>:</p>
				<c><![CDATA[
					var A = {
						x : 0
					};

					var B = A -> {
						y : 1
					};

					var C = B -> {
						z : 2
					};]]>
				</c>
			</h>
		</s>
		
		<s name="Multiple inheritance">
			<h name="JavaScript">
				<p>Is not supported. You can use some tricks (say mixins) but it is not true multiple inheritance.</p>
			</h>
			<h name="Goat">
				<p>Why not.</p>
				<c><![CDATA[
					var A = {
						x : 0
					};

					var B = {
						y : 1
					};

					var C = [A, B] -> {
						z : 2
					};]]>
				</c>
				<p>The solution of the problem of multiple inheritance ("the diamond problem"): Goat uses the list of prototypes to inherit from as an ordered list. The interpreter uses the first method it finds by depth-first searching.</p>
			</h>
		</s>	
	</s>
</goat>
