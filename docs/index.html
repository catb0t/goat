<html>
<head>
<meta charset="UTF-8">
<title>The Goat Programming Language Reference</title>
</head>
<body>
<h1>The Goat Programming Language Reference</h1>
<p>v0.1 "raw meat"</p>
<hr>
	
<h2>Introduction</h2>
<blockquote>
	<p><b>Goat</b> is a high-level, dynamic, weakly typed, prototype-based, multi-paradigm, and interpreted programming language, based on JavaScript. It supports the basic functionality of JavaScript, but in addition, it adds support for multithreading, multiple inheritance, operator overloading (all as in C ++), simplified syntax, and so on.</p>
	<p>Why "Goat"? At first I wanted to name this programming language as "Go", but unfortunately, some little-known company (it seems "Google" or something like that) has already developed a programming language with that name. After a while, when I programmed this interpreter on a laptop lying in a hammock, I was suddenly bitten by my goat. I thought that once the name "Go" is occupied, then perhaps the name "Goat" is no worse. I immediately named the project folder this name and since then it has not changed.</p>
</blockquote>

<h2>In comparison with JavaScript</h2>
<blockquote>
	<p>The Goat programming language based in general on JavaScript, but it has some differences:</p>
	<ul>
		<li>Interpreter is very small program and can be compiled and started in different platforms. I tried  Windows and Linux (both x86 and ARM). All you need are C++11 compiler and standart C library (libc etc).</li>
		<li>Programs starts not in browser, not in special environment (Node.js); you can write general-purpose applications. Easy to install: just copy the file with your code and interpreter and then start.</li>
		<li>Syntax is more simple, object model is more unificated.</li>
		<li>Goat language supports multi-threading and operators overloading.</li>
		<li>You can create object from more than one prototype.</li>
	</ul>
	<p>Some samples are below.</p>
	
	<h3>Primitive types</h3>
	<blockquote>
		<h4>JavaScript</h4>
		<p>A primitive data type is data that is not an object and has no methods. There are 6 primitive data types: string, number, boolean, null, undefined, symbol. All primitives are immutable.</p>
		<h4>Goat</h4>
		<p>There are no primitive types. All data represented as objects. Each object except <code>undefined</code> has some methods. There are some predefined objects which are prototypes for primitive data, such as numbers or strings: Char, String, Integer, <del>Real,</del> Boolean and Null.</p>
		<p>For determine what the type (prototype) of expression, use <code>instanceOf()</code> method:</p>
		<pre>
print(13.instanceOf(Integer)); // output: "true"
		</pre>		
	</blockquote>	
	
	<h3>Scope</h3>
	<blockquote>
		<h4>JavaScript</h4>
		<p>There are two types of scopes: global and local. Variables defined inside a function are in the local scope. Variables defined inside of a block statement will remain in the scope they were already in. ECMAScript 6 introduced the <code>let</code> keyword. Contrary to the <code>var</code> keyword, the <code>let</code> keyword support the declaration of local scope inside block statements.</p>
		<pre>
var func = function() {
	var v = 0;
	// do something...
	if (true) {
		let v = 1; // local declaration
	}
};
		</pre>		
		<h4>Goat</h4>
		<p>There is no global scope. You can re-declare variable with the same name in block statement, it will be used only in this block.</p>
		<pre>
var func = $() {
	var v = 0;
	if (true) {
		var v = 1;
		print(v); // output: "1"
	}
	print(v); // output: "0"
}
		</pre>		
	</blockquote>	
	
	<h3>Operators overloading</h3>
	<blockquote>
		<h4>JavaScript</h4>
		<p>Doesn't support.</p>
		<h4>Goat</h4>
		<p>You can use operator as method name:</p>
		<pre>
var Vector = {
	init : $(x, y) {
		this.x = x; this.y = y
	},
	toString : $() {
		return "X: " + x + ", Y: " + y;
	},
	"+" : $(vec) {
		return new Vector(x + vec.x, y + vec.y);
	},
	"*" : $(val) {
		return new Vector(x * val, y * val);
	}
};

var v1 = new Vector(100, 200);
var v2 = new Vector(200, 400);

print((v1 + v2).toString()); // output: "X: 300, Y: 600"
print(' ');
print((v1 * 5).toString()); // output: "X: 500, Y: 1000"
		</pre>
	</blockquote>
	
	<h3>Multithreading</h3>
	<blockquote>
		<h4>JavaScript</h4>
		<p>Doesn't support. There are some workarounds, say web workers, and, of course, functions <code>setTimeout()</code> and <code>setInterval()</code>.</p>
		<h4>Goat</h4>
		<p>There is <code>thread</code> keyword. It possible to declare any function as separate thread.</p>
		<pre>
var t0 = thread(){
	while(true) {
		print('A');
	}
};

var t1 = thread(){
	while(true) {
		print('B');
	}
};

t0.run();
t1.run();

// Output: "ABABABABABABAB...."
		</pre>
	</blockquote>

	<h3><code>new</code> keyword and constructors</h3>
	<blockquote>
		<h4>JavaScript</h4>
		<p>Constructors are like regular functions, but we use them with the <code>new</code> keyword. If you inherit your object and the parent has a constructor, you need to call parent constructor to perform initialization logic.</p>
		<pre>
var A = function() {
	// init something...
};

var B = function() {
	A.apply(this);
	// init something else...
};
B.prototype = new A();
		</pre>
		<h4>Goat</h4>
		<p>There is special method <code>init()</code>. If method defined, interpreter call it. If method also defined in base object, interpreter call it first (order of calling constructors as in C++).</p>
		<pre>
var A = {
	init : $() {
		// init something...
	}
};

var B = A -> {
	init : $() {
		// init something else...
	}
};

var obj = new B(); // both init method will be called, first from A, second from B
		</pre>
	</blockquote>

	<h3>Inheritance</h3>
	<blockquote>
		<h4>JavaScript</h4>
		<pre>
var A = function() {
	this.x = 0;
};

var B = function() {
	A.apply(this);
	this.y = 1;
};
B.prototype = new A();

var C = function() {
	B.apply(this);
	this.z = 2;
};
C.prototype = new B();
		</pre>
		<h4>Goat</h4>
		<p>Use operator <code>-&gt;</code>:</p>
		<pre>
var A = {
	x : 0
};

var B = A -> {
	y : 1
};

var C = B -> {
	z : 2
};
		</pre>
	</blockquote>
	
	<h3>Multiple inheritance</h3>
	<blockquote>
		<h4>JavaScript</h4>
		<p>Is not supported. You can use some tricks (say mixins) but it is not true multiple inheritance.</p>
		<h4>Goat</h4>
		<p>Why not.</p>
		<pre>
var A = {
	x : 0
};

var B = {
	y : 1
};

var C = [A, B] -> {
	z : 2
};
		</pre>
		<p>The diamond problem: Goat uses the list of prototypes to inherit from as an ordered list. The interpreter uses the first method it finds by depth-first searching.</p>
	</blockquote>
</blockquote>		
</body>
<html>